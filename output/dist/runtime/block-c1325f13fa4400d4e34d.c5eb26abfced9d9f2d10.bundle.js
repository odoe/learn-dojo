
(window['dojoWebpackJsonplearn_dojo'] = window['dojoWebpackJsonplearn_dojo'] || []).push([['runtime/block-c1325f13fa4400d4e34d'],{
/***/ 'runtime/block-c1325f13fa4400d4e34d.js':
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ([{"sortDate":"2019-09-05T00:00:00.000Z","file":"dojo-widget-middleware.md","content":"---\ntitle: Dojo Widget Middleware\ndate: 2019-09-05\nauthor: Rene Rubalcava\ndescription: Learn how to use middleware in Dojo function based widgets, managing local and application state, to build awesome applications!\ntags: javascript, dojo, webdev, dojo6\ncover_image: /assets/blog/dojo-widget-middleware.jpg\npublished: true\n---\n\nThe newest features of [Dojo 6](https://dojo.io/blog/version-6-dojo) include the new function based widgets and widget middleware.\n\nDojo class based widgets come with decorators to [watch for property changes](https://learn-dojo.com/watch-for-property-changes-in-widgets) and work with [metas](https://learn-dojo.com/dojo-from-the-blocks) which allow you to get information about your widget.\n\nWith the introduction of function based widgets, those patterns have been replaced by the new [middleware](https://dojo.io/learn/middleware/introduction) system.\n\n## Manage local state\n\nThere are two middlewares available for managing local state in a widget.\n\n* [cache](https://dojo.io/learn/middleware/available-middleware#cache) - persists data\n* [icache](https://dojo.io/learn/middleware/available-middleware#icache) - works like cache, but also invalidates the widget when data changes.\n\n### cache\n\nYou might use `cache` for some fine grained state management, because if you do use it, it's up to you to manually invalidate the widget, so that it will render based with updated `cache` properties using the `[invalidator`](https://dojo.io/learn/middleware/core-render-middleware#invalidator) middleware.\n\n```tsx\n// src/widgets/Parrot/Parrot.tsx\nimport { create, invalidator, tsx } from \"@dojo/framework/core/vdom\";\nimport cache from \"@dojo/framework/core/middleware/cache\";\n\nimport * as css from \"./Parrot.m.css\";\n\n// use `cache` and `invalidator` as middleware\n// in render factory\nconst factory = create({ cache, invalidator });\n\nexport const Parrot = factory(function Parrot({\n  middleware: { cache, invalidator }\n}) {\n  const name = cache.get<string>(\"name\") || \"\";\n  return (\n    <virtual>\n      <h3 classes={[css.root]}>{`Polly: ${name}`}</h3>\n      <input\n        classes={[css.input]}\n        placeholder=\"Polly want a cracker?\"\n        type=\"text\"\n        onkeyup={event => {\n          // update cache data with input value\n          cache.set(\n            \"name\",\n            (event.target as HTMLInputElement).value\n          );\n          // invalidate widget to render\n          // with new data\n          invalidator();\n        }}\n      />\n    </virtual>\n  );\n});\n\nexport default Parrot;\n```\n\nYou can see this demo in action here.\n\n!(https://codesandbox.io/embed/dojo-middleware-cache-3wc5n?fontsize=14&module=%2Fsrc%2Fwidgets%2FParrot%2FParrot.tsx)\n\nThis is fine, _but it could be easier_.\n\n### icache\n\nThe `icache` is designed specifically to work like `cache`, but to also run an `invalidator` on each update. It also comes with an extra method, `icache.getOrSet()` that will return the current value or a specified default value if none available.\n\n```tsx\n// src/widgets/Parrot/Parrot.tsx\nimport { create, tsx } from \"@dojo/framework/core/vdom\";\nimport icache from \"@dojo/framework/core/middleware/icache\";\n\nimport * as css from \"./Parrot.m.css\";\n\nconst factory = create({ icache });\n\nexport const Parrot = factory(function Parrot({ middleware: { icache } }) {\n  // get the current name value or an empty string\n  const name = icache.getOrSet(\"name\", \"\");\n  return (\n    <virtual>\n      <h3 classes={[css.root]}>{`Polly: ${name}`}</h3>\n      <input\n        classes={[css.input]}\n        placeholder=\"Polly want a cracker?\"\n        type=\"text\"\n        onkeyup={event => {\n          // when the cache is updated, it will\n          // handle calling the invalidator\n          icache.set(\n            \"name\",\n            (event.target as HTMLInputElement).value\n          );\n        }}\n      />\n    </virtual>\n  );\n});\n\nexport default Parrot;\n```\n\nThis would be equivalent to the [`@watch`](https://github.com/dojo/framework/tree/master/src/core#internal-widget-state) decorator that you can use with class based widgets. I would guess that 99% of the time, you would use `icache` to manage local state in your widgets.\n\n!(https://codesandbox.io/embed/dojo-middleware-icache-n6ktf?fontsize=14&module=%2Fsrc%2Fwidgets%2FParrot%2FParrot.tsx)\n\n## Application Store\n\nThere are a number of ways you could work [stores](https://dojo.io/learn/stores/introduction) in Dojo. You could use [containers](https://learn-dojo.com/dojo-containers) or a [provider](https://github.com/dojo/framework/tree/master/src/stores#advanced). _Or_, you could use a [store](https://dojo.io/learn/stores/introduction#store-middleware) middleware!\n\nWe can create a `store` middleware to hold a list of users.\n\n```ts\n// src/middleware/store.ts\nimport createStoreMiddleware from \"@dojo/framework/core/middleware/store\";\nimport { User } from \"../interfaces\";\n\nexport default createStoreMiddleware<{ users: User[] }>();\n```\n\nNow, we need a way to retrieve a list of users. We could do that via a [process](https://github.com/dojo/framework/tree/master/src/stores#processes), which is how you can manage application behavior.\n\nWe can build a process that will fetch some user data.\n\n```ts\n// src/processes/userProcess.ts\nimport {\n  createCommandFactory,\n  createProcess\n} from \"@dojo/framework/stores/process\";\nimport { replace } from \"@dojo/framework/stores/state/operations\";\n\nconst commandFactory = createCommandFactory();\n\nconst fetchUsersCommand = commandFactory(async ({ path }) => {\n  const response = await fetch(\"https://reqres.in/api/users\");\n  const json = await response.json();\n  return [replace(path(\"users\"), json.data)];\n});\n\nexport const getUsersProcess = createProcess(\"fetch-users\", [\n  fetchUsersCommand\n]);\n```\n\nWith a `store` and a `process` ready to, we can use them in a widget that will display our list of users.\n\n```tsx\n// src/widgets/Users/Users.tsx\nimport { create, tsx } from \"@dojo/framework/core/vdom\";\n\nimport * as css from \"./Users.m.css\";\n\nimport store from \"../../middleware/store\";\nimport { fetchUsersProcess } from \"../../processes/userProcesses\";\nimport { User } from \"../../interfaces\";\n\n// pass store to render factory\n// as middleware\nconst render = create({ store });\n\n// helper method to render list of Users\nconst userList = (users: User[]) =>\n  users.map(user => (\n    <li key={user.id} classes={[css.item]}>\n      <img\n        classes={[css.image]}\n        alt={`${user.first_name} ${user.last_name}`}\n        src={user.avatar}\n      />\n      <span classes={[css.title]}>\n        {user.last_name}, {user.first_name}\n      </span>\n    </li>\n  ));\n\nexport default render(function Users({ middleware: { store } }) {\n  // extract helper methods from the store in widget\n  const { get, path, executor } = store;\n  // get current value of Users\n  const users = get(path(\"users\"));\n  if (!users) {\n    // if no Users, run the `executor` against\n    // the process to fetch a list of Users\n    executor(fetchUsersProcess)(null);\n    // since the process to fetch Users does not need\n    // any arguments, execute with null\n\n    // if the network is slow, return\n    // a loading message\n    return <em>Loading users...</em>;\n  }\n\n  return (\n    <div classes={[css.root]}>\n      <h1>Users</h1>\n      <ul classes={[css.list]}>{userList(users)}</ul>\n    </div>\n  );\n});\n```\n\nThe key here is that the `store` middleware has an `executor` method that can be used to execute processes directly from your widget.\n\n```ts\nexecutor(fetchUsersProcess)(null);\n```\n\nIn this case, the `fetchUsersProcess` does not expect a payload, so we can pass `null` to it. If it needed to do pagination for example, we could pass which page we wanted as an argument and use it in our process.\n\nYou can see this demo in action here.\n\n!(https://codesandbox.io/embed/dojo-function-based-widgets-94eyy?fontsize=14&module=%2Fsrc%2Fwidgets%2FUsers%2FUsers.tsx)\n\n## Summary\n\nThere's more [middleware](https://dojo.io/learn/middleware/available-middleware) available that we didn't cover in this post, related to theming, i18n, DOM related, and interacting with the render method. We'll cover most of these in future blog posts!\n\nI'm really excited about all the new features in this latest release of Dojo and working with the available middleware and even what I could do with a [custom middlware](https://dojo.io/learn/middleware/middleware-fundamentals#creating-middleware)!\n\n","meta":{"title":"Dojo Widget Middleware","date":"2019-09-05T00:00:00.000Z","author":"Rene Rubalcava","description":"Learn how to use middleware in Dojo function based widgets, managing local and application state, to build awesome applications!","tags":"javascript, dojo, webdev, dojo6","cover_image":"/assets/blog/dojo-widget-middleware.jpg","published":true}},{"sortDate":"2019-08-28T00:00:00.000Z","file":"migrating-to-dojo-6.md","content":"---\ntitle: Migrating learn-dojo to Dojo 6\ndate: 2019-08-28\nauthor: Rene Rubalcava\ndescription: How I migrated the learn-dojo site to Dojo 6 and a look at the new function-based widgets capabilities!\ntags: javascript, typescript, dojo, webdev,  dojo6\ncover_image: /assets/blog/dojo-migrate-dojo6.jpg\npublished: true\n---\n\nThe latest release of [Dojo 6](https://dojo.io/) brings with it some major updates to how you can build apps with Dojo. There are some enhancements to builds, and custom elements, but I think one of the biggest new features available to developers is the use of function-based widgets. This doesn't mean you can't continue to use class-based widgets, but there are some nice advantages to using the new function-based widgets.\n\nIn case you didn't know, [learn-dojo](https://learn-dojo.com) is a static site, [built with Dojo](https://learn-dojo.com/building-static-site-with-dojo). So as Dojo 6 development was ongoing, I was already looking at what I would need to do to migrate the site to the latest Dojo.\n\n## Updates to Widgets\n\nLet's take a look at a basic [Header](https://github.com/odoe/learn-dojo/blob/df41818497429706e235c7b39437abb5ed4ee3b5/src/widgets/header/Header.tsx) widget, that accepts properties to display the title and and links to the main page.\n\n```tsx\n// src/widgets/header/Header.tsx\nimport WidgetBase from \"@dojo/framework/widget-core/WidgetBase\";\nimport { tsx } from \"@dojo/framework/widget-core/tsx\";\nimport Link from \"@dojo/framework/routing/Link\";\n\nimport * as css from \"./Header.m.css\";\n\nexport default class Header extends WidgetBase<{ title: string }> {\n  protected render() {\n    const { title } = this.properties || \"My Site\";\n    return (\n      <header classes={[css.root]}>\n        <div classes={[css.title]}>\n          <Link to=\"/\" isOutlet={false} classes={[css.link]}>\n            {title}\n          </Link>\n        </div>\n      </header>\n    );\n  }\n}\n```\n\nThis widget takes an object with a `title` that is a `string` as its property. This isn't a complicated widget, Now, when we convert it to a function-based widget, not much is going to change in terms of what is being rendered, but there are some slight differences in the [Header](https://github.com/odoe/learn-dojo/blob/c480ef742b088dd3bea9a28d686c35a3e551271b/src/widgets/header/Header.tsx).\n\n```tsx\n// converted to Dojo 6\n// src/widgets/header/Header.tsx\nimport { tsx, create } from '@dojo/framework/core/vdom';\n\nimport Link from '@dojo/framework/routing/Link';\n\nimport * as css from './Header.m.css';\n\nconst factory = create().properties<{ title: string }>();\n\nexport default factory(({ properties }) => {\n  const { title } = properties() || 'My Site';\n  return (\n    <header classes={[css.root]}>\n      <div classes={[css.title]}>\n        <Link to=\"/\" isOutlet={false} classes={[css.link]}>\n          {title}\n        </Link>\n      </div>\n    </header>\n  );\n});\n```\n\nFirst of all, the folder `widget-core` has been renamed to `core` in `@dojo/framework`. This is just a organizational change to Dojo. But the other new one is the use of this `create` module. The `create` module that lets you create a factory method for your render function.\n\nTo create a basic factory render function, you could do something like this.\n\n```tsx\n// return a render factory\nconst factory = create();\n\nexport factory(function MyBasicWidget() {\n  return <h2>Everything is awesome!</h2>;\n});\n```\n\nBut the `Header` widget requires some properties, so we can tell the render factory that properties are expected, and we can type them.\n\n```ts\nconst factory = create().properties<{ title: string }>();\n```\n\nNow in the factory method, it will be pass a `properties()` method that will return the provided properties to the widget.\n\n```tsx\nexport default factory(({ properties }) => {\n  const { title } = properties() || 'My Site';\n  ...\n});\n```\n\nWhy is `properties` a function and not just an object? This has to do with some other features of function-based widgets that allow middleware to be used. This ensures that you don't get stale values from the properties. \n\n_We'll cover the new middleware capabilities in more detail in in a future blog post_.\n\nThe rest of this widget looks like the previous version returning JSX vdom.\n\nIt is normally recommended that you provide _named_ render methods to the render factory as it will help you track down errors in debugging, but it isn't required. _Sometimes you just need to live on the edge_.\n\n## Basic Middleware\n\nOne of the standout features of Dojo is the use of [blocks](https://learn-dojo.com/dojo-from-the-blocks) that let you run code in node when you use build time rendering. It's critical in how learn-dojo is built because blocks are used to parse the posts from markdown, and run various tooling for code blocks, and formatting. In class-based widgets, this is done via the use metas.\n\nHere is how a blog page is rendered with a class-based widget.\n\n```tsx\n// src/pages/Blog.tsx\nimport WidgetBase from '@dojo/framework/widget-core/WidgetBase';\nimport Block from '@dojo/framework/widget-core/meta/Block';\nimport { tsx } from '@dojo/framework/widget-core/tsx';\n\nimport compileBlogIndex from '../blocks/compile-blog-index.block';\n\nimport Post from '../templates/blog-post/BlogPost';\n\nimport * as css from './Blog.m.css';\n\nexport default class Blog extends WidgetBase<{\n  standalone?: boolean;\n  path?: string;\n}> {\n  protected render() {\n    const { standalone = false, path } = this.properties;\n    // run the block as a meta\n    const blogs: any = this.meta(Block).run(compileBlogIndex)({});\n    // render blog excerpts or single blog post\n    return (\n      <div classes={[css.root]}>\n        {!standalone\n          ? blogs &&\n            blogs.map((blog: any) => [\n              <Post key={blog.file} path={blog.file} excerpt />,\n              <hr key={blog.file} />\n            ])\n          : undefined}\n        {path && path.length && <Post key={path} path={path} />}\n      </div>\n    );\n  }\n}\n```\n\nLet's dive right into how the [Blog](https://github.com/odoe/learn-dojo/blob/c480ef742b088dd3bea9a28d686c35a3e551271b/src/pages/Blog.tsx) module looks as a function-based widget in Dojo 6.\n\n```tsx\n// converted to Dojo 6\n// src/pages/Blog.tsx\nimport { tsx, create } from '@dojo/framework/core/vdom';\nimport block from '@dojo/framework/core/middleware/block';\n\nimport compileBlogIndex from '../blocks/compile-blog-index.block';\n\nimport Post from '../templates/blog-post/BlogPost';\n\nimport * as css from './Blog.m.css';\n\nconst factory = create({ block }).properties<{ standalone?: boolean; path?: string }>();\n\nexport default factory(({ middleware: { block }, properties }) => {\n  const { standalone = false, path } = properties();\n  const blogs: any = block(compileBlogIndex)({});\n\n  return (\n    <div classes={[ css.root ]}>\n      {!standalone ? (\n        blogs &&\n        blogs.map((blog: any) => [\n          <Post key={blog.file} path={blog.file} excerpt />,\n          <hr key={blog.file} />\n        ])\n      ) : (\n        undefined\n      )}\n      {path && path.length && <Post key={path} path={path} />}\n    </div>\n  );\n});\n\n```\n\nTo use this in a render factory method, pass the block middleware to the `create` method so that it's available to your render factory.\n\nAnything you pass into the create() method will be available to your render factory methods as middleware.\n\n```ts\nconst factory = create({ block }).properties<{ standalone?: boolean; path?: string }>();\n\n// render factory\nexport default factory(({ middleware: { block }, properties }) => {...});\n```\n\nNow the `block` is available on the `middleware` property passed to the render factory method.\n\n```ts\nconst blogs: any = block(compileBlogIndex)({});\n```\n\nNotice that now, you can run the middleware block independently of any `meta` helpers like in a class-based method. This is one of my favorite features of the new function-based widgets!\n\n## Composable Widgets\n\nThe learn-dojo site takes advantage of the ability to create wrapper widgets that renders any children provided to it. This is used in something like the [`Layout`](https://github.com/odoe/learn-dojo/blob/df41818497429706e235c7b39437abb5ed4ee3b5/src/layouts/Layout.tsx) widget.\n\n```tsx\n// src/layouts/Layout.tsx\nexport default class Layout extends WidgetBase<SiteMeta> {\n  protected render() {\n    const { title, description, author, footerLinks } = this.properties;\n    return (\n      <div classes={[css.root]}>\n        <Header title={title} />\n        <Hero description={description} />\n        {/* render the children */}\n        <main classes={[css.section]}>{this.children}</main>\n        <SignUp />\n        <Footer {...{ author, footerLinks }} />\n      </div>\n    );\n  }\n}\n```\n\nLike the update to make `properties` a function so you always have the latest values, the same is true for `children` now being a function in the [Layout](https://github.com/odoe/learn-dojo/blob/c480ef742b088dd3bea9a28d686c35a3e551271b/src/layouts/Layout.tsx).\n\n```tsx\n// converted to Dojo 6\n// src/layouts/Layout.tsx\nconst factory = create().properties<SiteMeta>();\n\nexport default factory(({ children, properties }) => {\n  const { title, description, author, footerLinks } = properties();\n\n  return (\n    <div classes={[ css.root ]}>\n      <Header title={title} />\n      <Hero description={description} />\n      {/* render the children */}\n      <main classes={[ css.section ]}>{children()}</main>\n      <SignUp />\n      <Footer {...{ author, footerLinks }} />\n    </div>\n  );\n});\n```\n\nThat's the only change in regard to rendering children in your widgets.\n\n## Summary\n\nDojo 6 is a significant release in the Dojo roadmap, offering some exciting new capabilities in build reactive widgets for your applications. There are plenty more new features not covered in this blog post that will be discussed in the future. For details, see the [official Dojo 6 blog post](https://dojo.io/blog/version-6-dojo).\n\nI was able to migrate [learn-dojo](https://learn-dojo.com/) in a single morning based off the new Dojo documentation. I'm really impressed with the new function-based widget pattern in Dojo and the use of middleware that we barely scratched the surface of in this post.\n\nStay tuned for more!\n","meta":{"title":"Migrating learn-dojo to Dojo 6","date":"2019-08-28T00:00:00.000Z","author":"Rene Rubalcava","description":"How I migrated the learn-dojo site to Dojo 6 and a look at the new function-based widgets capabilities!","tags":"javascript, typescript, dojo, webdev,  dojo6","cover_image":"/assets/blog/dojo-migrate-dojo6.jpg","published":true}},{"sortDate":"2019-07-14T00:00:00.000Z","file":"dojo-process-middleware.md","content":"---\ntitle: Using Middleware with Dojo Processes\ndate: 2019-07-14\nauthor: Rene Rubalcava\ndescription: How you can inject yourself into the Dojo process, juggle your data, and manage state updates\ntags: javascript, web development, dojo, dojo5\ncover_image: /assets/blog/dojo-process-middleware.jpg\npublished: true\n---\n\nWe previously looked at how you can manage state in Dojo with [processes and stores](https://learn-dojo.com/maintain-state-with-dojo-stores). This isn't only a flexible way you can manage state in your applications, but it provides some hooks for you to be able to stick your nose into your applications business.\n\nMaybe you want to manage some state in your application when you begin to fetch data and when you have completed fetching data. You could try to manage this in the widget itself or maybe in the process. This is kind of tricky though. Each process can update the store, and you could even run multiple processes at the same time, but it's treated as a single transaction. So you can't really start a process, change the `loading` state and change it back when you're done in a way that would update your widget in that single transaction.\n\n```ts\n// src/processes/starwarsProcesses.ts\nconst fetchItems = commandFactory<Item>(async ({ path }) => {\n  // where do we change the starting state?\n  const response = await fetch(\"https://swapi.co/api/\");\n  const json = await response.json();\n  const items: Item[] = Object.keys(json).map(key => {\n    return {\n      label: key,\n      value: json[key]\n    };\n  });\n  // this workflow doesn't work, the widget never gets the 'true' state\n  // this is a single transaction\n  return [\n    replace(path(\"loading\"), true),\n    replace(path(\"items\"), items),\n    replace(path(\"loading\"), false)\n  ];\n});\n```\n\n## Middleware\n\nBut fear not! Dojo has a way for you to run some middleware on your processes to do all sorts of cool things! There is some more detailed information [here](https://github.com/dojo/framework/tree/master/src/stores#middleware).\n\nWhat kind of tasks can you do with middleware?\n\n* Transform the fetched result of your process.\n* Validate arguments passed to your process.\n* Define a loading state.\n* Add logging and telemetry.\n* Runtime caching.\n\nAnd I'm sure you can think of many more uses!\n\nThe middleware API allows you to provide `after` and `before` methods. So in my use case above, We can update the `loading` state of the process before and after it begins.\n\n![](/assets/images/dojo-process-middleware/middleware-flow.png)\n\nTo update some loading state, that could look like this!\n\n```ts\n// src/processes/starWarsProcess.ts\nconst progress: ProcessCallback = () => ({\n  before(payload, { apply, path }) {\n    // update the app store before the process is run\n    apply([replace(path(\"loading\"), true)], true);\n  },\n  after(error, { apply, path }) {\n    // update the app store when process is finished\n    apply([replace(path(\"loading\"), false)], true);\n  }\n});\n```\n\nIn the middleware methods, we're given an `apply` and a `path`. The `apply` lets us _apply_ an operation to the store, and the `path` lets us pick the property that we want to act on. In this case, we can use the `replace` operation to _update_ an existing property. This state update will propagate to any other parts of the application that are using this store.\n\nNow we can update the process to use this middleware!\n\n```ts\n// src/processes/starWarsProcess.ts\nexport const fetchItemsProcess = createProcess(\n  \"fetch-items\", // process name\n  [fetchItems],  // command\n  [progress]     // middleware\n);\n```\n\nWith the middleware in place, we can update the widget so that it can recognize when data is being fetched.\n\n```tsx\n// src/widgets/APIExplorer.tsx\nexport class APIExplorer extends WidgetBase<ExplorerProperties> {\n  ...\n  render() {\n    return (\n      ...\n      <TextArea\n       rows={25}\n       theme={theme}\n       value={loading ? \"Loading...\" : result}\n      />\n      ...\n    );\n  }\n  ...\n}\n```\n\nNow in the widget, if the store `loading` state is true, we can show some loading text, if it's not loading, we can show the result!\n\nYou can see what this looks like in this [code sandbox](https://codesandbox.io/embed/dojo-stores-middleware-ho8kn?fontsize=14&module=%2Fsrc%2Fprocesses%2FstarwarsProcesses.ts)!\n\n## Summary\n\nThe ability to have the after/before middleware in our application state is not only practical, but incredibly flexible. We've just scratched the surface of what you can do with Dojo middleware, but I'm excited about the possibilities and I'm sure you are too!\n","meta":{"title":"Using Middleware with Dojo Processes","date":"2019-07-14T00:00:00.000Z","author":"Rene Rubalcava","description":"How you can inject yourself into the Dojo process, juggle your data, and manage state updates","tags":"javascript, web development, dojo, dojo5","cover_image":"/assets/blog/dojo-process-middleware.jpg","published":true}},{"sortDate":"2019-06-17T00:00:00.000Z","file":"dojo-graphql.md","content":"---\ntitle: Dojo GraphQL\ndate: 2019-06-17\nauthor: Rene Rubalcava\ndescription: How you can integrate GraphQL into your Dojo applications with Apollo and Dojo containers\ntags: javascript, dojo, webdev, graphql, dojo5\ncover_image: /assets/blog/dojo-graphql.jpg\npublished: true\n---\n\n[GraphQL](https://graphql.org/) has grown in popularity over the past couple of years. Where GraphQL shines is in its descriptive nature of querying data.\n\nIf you want to write a query for the [Star Wars API](https://swapi.co/) to get all the film titles, it might look something like this.\n\n```\n{\n  allFilms{\n    edges{\n      node{\n        title\n      }\n    }\n  }\n}\n```\n\nThe query is _JSON-like_, but it's not JSON. You can learn more about GraphQL on the [tutorials page](https://www.graphql.com/tutorials/).\n\n[Apollo](https://github.com/apollographql/apollo-client) provides a client API you can use to work with GraphQL. It saves you some work of writing your own POST requests, so I highly recommend you learn it. Apollo provides libraries to integrate with Angular and React, but so far not one for Dojo. But that's ok, because you can use the Apollo Client to build your own GraphQL integration.\n\nLooking at [react-apollo](https://github.com/apollographql/react-apollo), they have an `ApolloProvider` that you can use to wrap components of your application. This provides the Apollo client to components. Those components can then use a `Query` higher order component to pass the query and client and thus display the result.\n\n_How hard can that be?_\n\n## Trust the Process\n\nWhen working with Dojo, most of your work with external APIs is probably going to be done in a [process](https://github.com/dojo/framework/tree/master/src/stores#processes). We covered this topic in detail in [this post](https://learn-dojo.com/maintain-state-with-dojo-stores).\n\nHere is what a generic process for working with GraphQL might look like.\n\n```ts\n// src/processes/apolloProcess.ts\nimport {\n  createProcess,\n  createCommandFactory\n} from \"@dojo/framework/stores/process\";\nimport { add } from \"@dojo/framework/stores/state/operations\";\n\nconst commandFactory = createCommandFactory<{\n  client: any; // this will be the apollo client\n  data: any; // this will be graphql result\n  loaded: boolean; // keep track if the data has been loaded yet\n}>();\n\nconst fetchData = commandFactory(async ({ path, payload }) => {\n  const { client, query } = payload;\n  const { data } = await client.query({ query });\n  return [add(path(\"data\"), data), add(path(\"loaded\"), true)];\n});\n\nexport const fetchDataProcess = createProcess(\"fetch-data\", [fetchData]);\n```\n\nThis process will take a given apollo client instance and a GraphQl query to fetch some results. This works pretty well because it's not tied to any particular endpoint or data structure, even though it is currently typed as `any` for client and data. I could try to work around that with some generics, but wanted to keep this example fairly simple.\n\n## Put it in a box\n\nWe can tie this together with a widget and [Dojo container](https://dojo.io/tutorials/1010_containers_and_injecting_state/).\n\n```tsx\n// src/containers/QueryContainer.tsx\nimport { tsx } from \"@dojo/framework/widget-core/tsx\";\nimport { WidgetBase } from \"@dojo/framework/widget-core/WidgetBase\";\n\nimport { Store } from \"@dojo/framework/stores/Store\";\nimport { StoreContainer } from \"@dojo/framework/stores/StoreInjector\";\n\nimport { fetchDataProcess } from \"../processes/apolloProcess\";\n\n// Use the ApolloClient for typing\nimport ApolloClient from \"apollo-boost\";\n\ninterface QueryProps {\n  client?: ApolloClient<any>;\n  query: string;\n  data?: any;\n  loaded?: boolean;\n  fetchData?: (args: any) => void;\n}\n\n// base widget that handles displaying children that use the Query\nexport class BaseQuery extends WidgetBase<QueryProps, any> {\n  onAttach() {\n    const { client, query, loaded, fetchData } = this.properties;\n    // if the data has not been loaded yet\n    // and we have a query, lets get some data\n    if (!loaded && query) {\n      fetchData({ client, query });\n    }\n  }\n  protected render() {\n    const { loaded, data } = this.properties;\n    return this.children.map(child => {\n      // if the child nodes are a function,\n      // call the function with data from the\n      // GraphQL process\n      if (typeof child === \"function\") {\n        return child({ loading: !loaded, data });\n      }\n      // or just return a regular node\n      return child;\n    });\n  }\n}\n\nfunction getProperties(store: Store<{ data: any; loaded: boolean }>): any {\n  const { get, path } = store;\n\n  // pass the Dojo store properties and methods to the widget\n  return {\n    data: get(path(\"data\")),\n    loaded: get(path(\"loaded\")),\n    fetchData: fetchDataProcess(store)\n  };\n}\n// Use a StoreContainer\nexport const Query = StoreContainer(BaseQuery, \"state\", {\n  getProperties\n});\n```\n\nIn this snippet we provide a `BaseQuery` that is going to handle taking any queries that child widgets might provide and use those queries to to fetch some data. This widget uses a `StoreContainer` to pass the store that is updated using our process to the `BaseQuery`. We can call this container a `Query` to keep it simple. This is going to allow us to write some code like the following.\n\n```tsx\nexport class MyWidget extends WidgetBase<{ client: any }> {\n  protected render() {\n    const { client } = this.properties;\n    return (\n      // use our Query Widget with the client it's given and\n      // a query we have written\n      <Query query={query} client={client}>\n        {({ loading, data }) => {\n          if (loading) {\n            return <span>Loading...</span>;\n          } else {\n            return <div classes={[css.root]}>{parseMyData(data)}</div>;\n          }\n        }}\n      </Query>\n    );\n  }\n}\n```\n\n## Be a good provider\n\nAt this point you might be asking yourself, _How do I pass a client to a widget that uses this?_\n\nGood question. Technically, you could create the client in your Widget module and provide it to `<Query>`. But that seems kind of icky to bind backend concerns into my UI code. The way `react-apollo` does this is by providing an `<ApolloProvider>` that you can give a `client` and then wrap your application components with it. These components will have access to the Apollo `client` to give to the `Query` higher order component.\n\nIt basically looks like the `<ApolloProvider>` _provides_ its `client` property to child widgets. _I can do that_.\n\n```tsx\n// src/providers/ApolloProvider.tsx\nimport { tsx } from \"@dojo/framework/widget-core/tsx\";\nimport { WidgetBase } from \"@dojo/framework/widget-core/WidgetBase\";\n\nexport class ApolloProvider extends WidgetBase<{ client: any }> {\n  protected render() {\n    const { client } = this.properties;\n    for (let child of this.children) {\n      if ((child as any).properties) {\n        // inject the client of the provider into each child\n        // widget\n        (child as any).properties.client = client;\n      }\n    }\n    return this.children;\n  }\n}\n```\n\nWhat this _naive_ `ApolloProvider` does is iterates over the `children` of the widget and injects the `client` property into each one. I'm sure the `react-apollo` implementation does much more, but I'm not going to argue with what works.\n\nNow that I have my provider, I can start to tie it all together.\n\n## The great provider\n\nIn my `main.tsx` where I initialize my Dojo application, I can create my `ApolloClient` and pass it my `ApolloProvider` that will wrap my other widgets so that I can use it.\n\n```tsx\n// src/main.tsx\n...\nimport { Store } from \"@dojo/framework/stores/Store\";\nimport { registerStoreInjector } from \"@dojo/framework/stores/StoreInjector\";\n\nimport ApolloClient from \"apollo-boost\";\n\nimport { ApolloProvider } from \"./providers/ApolloProvider\";\nimport { Countries } from \"./widgets/Countries\";\n\n// initialize a GraphQL client\nconst client = new ApolloClient({\n  uri: \"https://countries.trevorblades.com\"\n});\n\nconst store = new Store();\nconst registry = registerStoreInjector(store);\n\nclass App extends WidgetBase {\n  protected render() {\n    // pass the client to the ApolloProvider\n    // The <Countries /> widget will use it\n    return (\n      <div>\n        <ApolloProvider client={client}>\n          <h2>{\"\\u2728 dojo-apollo \\u2728\"}</h2>\n          <Countries />\n        </ApolloProvider>\n      </div>\n    );\n  }\n}\n...\n```\n\nThe sample GraphQL API I am going to use provides a list of Countries. So I'm going to write a widget that can display those results.\n\n## GraphQL results\n\nHere is where we get to see the fruit of our labors! We can write a widget that will display a specific set of data from our GraphQL API. So the widget can provide its own GraphQL query. This makes sense when you think of the widget as _owning_ this query.\n\n```tsx\nimport { tsx } from \"@dojo/framework/widget-core/tsx\";\nimport { WidgetBase } from \"@dojo/framework/widget-core/WidgetBase\";\nimport gql from \"graphql-tag\";\n\nimport * as css from \"./styles/Countries.m.css\";\n\nimport { Query } from \"../containers/QueryContainer\";\n\ninterface Country {\n  name: string;\n  code: number;\n}\n// initialize a GraphQL query\nexport const query = gql`\n  {\n    countries {\n      name\n      code\n    }\n  }\n`;\n\n// helper method to display each country as a list item\n// each country will link to a wikipedia page\nconst countryItems = (countries: Country[] = []) =>\n  countries.map(({ name, code }) => (\n    <li classes={[css.item]} key={code}>\n      <a\n        classes={[css.link]}\n        key={code}\n        href={`https://en.wikipedia.org/wiki/${name}`}\n        target=\"_blank\"\n      >\n        {name}\n      </a>\n    </li>\n  ));\n\nexport class Countries extends WidgetBase<{ client?: any }> {\n  protected render() {\n    // this is the `client` that was injected by the `<ApolloProvider>`\n    const { client } = this.properties;\n    return (\n      <Query query={query} client={client}>\n        {({ loading, data }) => {\n          // if data is still loading, show a message\n          if (loading) {\n            return <span>Loading...</span>;\n          } else {\n            // when data is done loading, display the list\n            return <ul classes={[css.root]}>{countryItems(data.countries)}</ul>;\n          }\n        }}\n      </Query>\n    );\n  }\n}\n```\n\nThis widget uses our `Query` container to wrap up the part of the widget that relies on the GraphQL results. This looks pretty much exactly like `react-apollo`.\n\nYou can see this entire example in action in this [code sandbox](https://codesandbox.io/s/dojo-graphql-zgmi6?fontsize=14).\n\n## Summary\n\nThis is a fairly simple implementation of a GraphQL `<Query>` and `<ApolloProvider>`, but it works pretty well in a case like this. If you have multiple different queries you want to run in a single application, I think you would need to create a factory method for your containers to define multiple states that would contain different results.\n\nThis is definitely something I want to continue working on in the future and I think there might be some more _Dojo way_ of handling this in some features that look to be coming to Dojo in the future.\n\nAs always, have fun with it and keep on hacking!\n","meta":{"title":"Dojo GraphQL","date":"2019-06-17T00:00:00.000Z","author":"Rene Rubalcava","description":"How you can integrate GraphQL into your Dojo applications with Apollo and Dojo containers","tags":"javascript, dojo, webdev, graphql, dojo5","cover_image":"/assets/blog/dojo-graphql.jpg","published":true}},{"sortDate":"2019-05-28T00:00:00.000Z","file":"building-static-site-with-dojo.md","content":"---\ntitle: Building a static site with dojo\ndate: 2019-05-28\nauthor: Rene Rubalcava\ndescription: We'll look at how you can use dojo as a static site generator\ntags: javascript, dojo, typescript, webdev\ncover_image: /assets/blog/building-static-site-with-dojo.jpg\npublished: true\n---\n\nWe've seen how you can use [dojo blocks](https://learn-dojo.com/dojo-from-the-blocks) with [build-time-rendering](https://learn-dojo.com/build-time-rendering-in-dojo) to create static web pages. This is pretty powerful, because it means you _could_ build an entire website without having to back with API and database calls. Of course, this isn't ideal web applications that require dynamic data or handle authorization, but it is ideal for situations where the content is fairly static, like documentation or [this blog](https://github.com/odoe/learn-dojo)! This is very much what something like [gatsby](https://www.gatsbyjs.org/) is for. All the pieces to build a static site generator are there in dojo, you just need to put them together.\n\n## Parsing\n\nI was heavily inspired by what the dojo team is doing with [dojo/site](https://github.com/dojo/site) to statically build the pages for the next [dojo](http://dojo.io/) documentation. I borrowed heavily from their blocks to parse markdown to virtual dom nodes as I found I was recreating the wheel.\n\nMy main goal for my static site generator was to parse markdown to pages, specifically blog pages. The core tools in this process are [unified](https://github.com/unifiedjs/unified) and [remark](https://github.com/remarkjs/remark). If you have built sites with gatsby, you may be familiar with these as they are used heavily in gatsby plugins.\n\nHere is a sample of the block used to parse markdown looks like.\n\n```ts\n// Converts markdown to VNodes in hyperscript\nexport const toVNodes = (content: string) => {\n\tlet counter = 0;\n\tconst pipeline = unified()\n\t\t.use(markdown as any, { commonmark: true })\n\t\t.use(externalLinks, { target: '_blank', rel: [ 'nofollow' ] })\n\t\t.use(frontmatter, 'yaml')\n\t\t.use(remark2rehype)\n\t\t.use(slug)\n\t\t.use(rehypePrism);\n\n\tconst nodes = pipeline.parse(content);\n\tconst result = pipeline.runSync(nodes);\n\treturn toH((tag: string, props: any, children: any[]) => v(tag, { ...props, key: counter++ }, children), result);\n};\n```\n\nThis block function uses `unified` to parse a markdown file. The result of parsing this file is a [markdown abstract tree](https://github.com/syntax-tree/mdast) that is then passed through a series of remark plugins to transform that markdown into a product that we can then parse to HTML with [rehype](https://github.com/rehypejs/rehype) and some other rehype plugins. Once that is done, we can transform this product to hyperscript using [hast-to-hyperscript](https://github.com/syntax-tree/hast-to-hyperscript) using the built in dojo virtual dom tooling to produce the needed nodes.\n\n## Routing\n\nI wasn't just building a static site generator for this blog. I was porting an existing wordpress blog to a static site. So I wanted to make sure that all the existing links out there would still work, so I had to mimic the existing structure. To do this, my routes look like this.\n\n```ts\nexport default [\n\t{\n\t\tpath: '/{path}',\n\t\toutlet: 'blog',\n\t\tdefaultRoute: true\n\t}\n];\n```\n\nThe root of the route would be `/` and blog posts links would go to `/{path}`. I wanted the home page to consist of a list of the blog posts with the published date and descriptions. So I made a card widget to display these.\n\n```tsx\nexport default class Card extends WidgetBase<CardProperties> {\n\tprotected render() {\n\t\tconst { title, date, description, path, cover_image } = this.properties;\n\t\treturn (\n\t\t\t<section classes={[ css.root ]}>\n\t\t\t\t<div classes={[ css.column ]}>\n\t\t\t\t\t<Link\n\t\t\t\t\t\tto=\"blog\"\n\t\t\t\t\t\tparams={{\n\t\t\t\t\t\t\t// markdown is a posts/ folder with extension .md\n\t\t\t\t\t\t\t// so clean that up\n\t\t\t\t\t\t\tpath: path.replace('posts/', '').replace('.md', '')\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t{title}\n\t\t\t\t\t</Link>\n\t\t\t\t\t<p>{dateFormatter(new Date(date))}</p>\n\t\t\t\t\t<span>{description}</span>\n\t\t\t\t\t<br />\n\t\t\t\t\t<Link\n\t\t\t\t\t\tto=\"blog\"\n\t\t\t\t\t\tparams={{\n\t\t\t\t\t\t\tpath: path.replace('posts/', '').replace('.md', '')\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\tREAD MORE\n\t\t\t\t\t</Link>\n\t\t\t\t</div>\n\t\t\t\t<div classes={[ css.column ]}>\n\t\t\t\t\t<img classes={[ css.image ]} src={cover_image} />\n\t\t\t\t</div>\n\t\t\t</section>\n\t\t);\n\t}\n}\n```\n\nI'm using the metadata from each blog post to create these cards. I'm using a lot of the front matter for metadata that [dev.to](https://dev.to) uses, because it will make it easier for me to cross-post there as well.\n\nThe result is a card that looks similar to this.\n\n![dojo blog card](/assets/blog/dojo-blog-card.png)\n\n## Templates\n\nBlog posts are represented as templates. In this case they can render in a card style for the main page or as the entire blog post. The blog post template looks like this.\n\n```tsx\nexport default class BlogPost extends WidgetBase<PostProperties> {\n\tprotected render() {\n\t\tlet { excerpt = false, path } = this.properties;\n\t\tif (!path.includes('.md')) {\n\t\t\tpath = `${path}.md`;\n    }\n\t\t// compile the blog post content\n\t\tconst post: any = this.meta(Block).run(compileBlogPost)({\n\t\t\tpath\n\t\t});\n\t\tif (post) {\n      const date = dateFormatter(new Date(post.meta.date));\n\t\t\t// if displayed as a card, just return the content in card format\n\t\t\tif (excerpt) {\n\t\t\t\treturn <Card path={path} {...post.meta} />;\n      }\n\t\t\t// or return the content as a full blog post\n\t\t\treturn (\n\t\t\t\t<Content key={post.meta.title}>\n\t\t\t\t\t{!excerpt && <img src={post.meta.cover_image} />}\n\t\t\t\t\t<Link\n\t\t\t\t\t\tto=\"blog\"\n\t\t\t\t\t\tparams={{\n\t\t\t\t\t\t\tpath: path.replace('posts/', '').replace('.md', '')\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<h2>{post.meta.title}</h2>\n\t\t\t\t\t</Link>\n\t\t\t\t\t<p>\n\t\t\t\t\t\t{post.meta.author} | {date}\n\t\t\t\t\t</p>\n\t\t\t\t\t{post.content}\n\t\t\t\t</Content>\n\t\t\t);\n\t\t}\n\t}\n}\n```\n\n_The results of this looks just like this blog!_\n\n## Building\n\nIn order for the static pages to be built, I need to configure my `.dojorc` correctly with the routes to all my blog posts. Note that `\".\"` is how I can tell the dojo build-time-render to build a static index page.\n\n```json\n{\n\t\"build-app\": {\n\t\t\"build-time-render\": {\n\t\t\t\"root\": \"root\",\n\t\t\t\"paths\": [\n\t\t\t\t\"build-time-rendering-in-dojo\",\n\t\t\t\t\"building-a-simple-app-in-dojo\",\n\t\t\t\t\"build-static-site-with-dojo\",\n\t\t\t\t\"creating-a-datepicker-with-dojo\",\n\t\t\t\t\"dojo-cli-template-app\",\n\t\t\t\t\"dojo-containers\",\n\t\t\t\t\"dojo-from-the-blocks\",\n\t\t\t\t\"intro-to-the-dojo-registry\",\n\t\t\t\t\"intro-to-the-dojo-router\",\n\t\t\t\t\"maintain-state-with-dojo-stores\",\n\t\t\t\t\"style-dojo-widgets\",\n\t\t\t\t\"testing-with-dojo\",\n\t\t\t\t\"up-and-running-with-dojo-cli\",\n\t\t\t\t\"watch-for-property-changes-in-widgets\",\n\t\t\t\t\"web-components-with-dojo\",\n\t\t\t\t\".\"\n\t\t\t],\n\t\t\t\"puppeteerOptions\": {\n\t\t\t\t\"args\": [ \"--no-sandbox\", \"--disable-setuid-sandbox\" ]\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\nI'm planning on automating the updates of the `.dojorc` with a script that I can run before the build is run, but I haven't gotten that far yet.\n\nOnce it's been built, the result is a static website with subdirectories to each page I've built.\n\n![dojo buil time render result](/assets/blog/dojo-btr-built.png)\n\nThis means that even if someone is on a slow connection or the javascript doesn't load correctly, my site should still be visible, including the routes of my site.\n\n## Deployment\n\nSince my site doesn't require making any API calls or rely on a server to do any server side rendering, it's fairly easy to deploy to any number of your favorite hosting services. For the record, I tried to deploy to [zeit](https://zeit.co/) and [netlify](https://www.netlify.com/) and they both appeared to work great at first. However, it looks like the subdirectories of my `dist` directory would not deploy, so links to pages other than the main page would not work. If I linked to a page from the main page, dojo routing worked fine, but not when using the URL. I'm sure I just did not configure something correctly, but it wasn't clear to me _what_ I didn't do right.\n\nSo at the end of the day, I deployed to [aws s3](https://aws.amazon.com/s3/). Although, s3 configuration isn't exactly _simple_, I know enough to drag and drop the folders over and I could even set up a pipeline from github. I'll probably need to add a `published` tag to my posts like [dev.to](https://dev.to/) does so I an push posts in progress to github without deploying them with the rest of the site.\n\nThere is plenty more I want to do with this project going forward!\n\n## For web apps\n\nMy blog is not a full blown web application, but that doesn't mean you can't take the same static site generating tools of dojo to build a _mostly_ static site that will also fetch data from external sources and use them both to build powerful web applications. The static site generating tools are just one piece of a larger system of powerful features built in to dojo.\n\n## Try it yourself\n\nIf you want to try this dojo static site generator out yourself, you can quickly get started with the following command.\n\n```bash\nnpx degit odoe/btr-site my-awesome-site\n```\n\nYou can check out this starter project on [github](https://github.com/odoe/btr-site)!\n\n## Summary\n\nI've had a lot of fun putting this project together and learned a lot about how unified, remark, rehype, and other plugins work, as well as how to really use dojo blocks to do some interesting things. I may not have all the bells and whistles of wordpress, but I don't think I fully need them. Anything substantial that wordpress could tell me, I can get from google analytics and I'm much more comfortable just publishing in markdown anyway. It also won't hurt to save a few bucks on that digital ocean bill :)\n","meta":{"title":"Building a static site with dojo","date":"2019-05-28T00:00:00.000Z","author":"Rene Rubalcava","description":"We'll look at how you can use dojo as a static site generator","tags":"javascript, dojo, typescript, webdev","cover_image":"/assets/blog/building-static-site-with-dojo.jpg","published":true}},{"sortDate":"2019-05-06T00:00:00.000Z","file":"testing-with-dojo.md","content":"---\ntitle: Testing with Dojo\ndate: 2019-05-06\nauthor: Rene Rubalcava\ndescription: How to use the testing tools of the Dojo framework\ntags: javascript, dojo, tdd, testing\ncover_image: /assets/blog/testing-with-dojo.jpg\npublished: true\n---\n\nWhen you use the [Dojo cli](https://github.com/dojo/cli) to create an application, it comes with a full test framework for you to use. If like me, you aren't as diligent with your tests as you maybe you could be, that's ok, there's no testing police that will give you a citation, _only your own shame when you try to track down how you broke some feature after some updates you made_. I kid, I kid. But, it is a good idea to have some tests written to make sure core features of your application don't break as you write new code.\n\nWhen you first create a Dojo application, it will already provide you with some unit tests that you can use as a guide.\n\n<figure class=\"aligncenter\">![](assets/blog/test-structure.png)\n\n<figcaption>Default Dojo Installation  \n</figcaption>\n\n</figure>\n\nYou can find this sample repo [on github](https://github.com/odoe/dojo-testing).\n\nLet's see what a unit test looks like.\n\n## Running Tests\n\nYou can run these tests using `npm test` and you should get results like below.\n\n<figure class=\"aligncenter\">![](assets/blog/test-results.png)\n\n<figcaption>Dojo testing results</figcaption>\n\n</figure>\n\n\nSo what does one of these tests look like?\n\n```ts\n// tests/unit/widgets/Profile.ts\nconst { describe, it } = intern.getInterface(\"bdd\");\nimport harness from \"@dojo/framework/testing/harness\";\nimport { w, v } from \"@dojo/framework/widget-core/d\";\n\nimport Profile from \"../../../src/widgets/Profile\";\nimport * as css from \"../../../src/widgets/styles/Profile.m.css\";\n\ndescribe(\"Profile\", () => {\n  it(\"default renders correctly\", () => {\n    const h = harness(() => w(Profile, { username: \"Dojo User\" }));\n    h.expect(() => v(\"h1\", { classes: [css.root] }, [\"Welcome Dojo User!\"]));\n  });\n});\n```\n\nWhen testing widgets, you are basically testing that the output of the widget is what you expect, especially when given a set of properties. Ideally, rendering a widget is going to be _[pure function](https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch03.md#chapter-03-pure-happiness-with-pure-functions)_, meaning they should be pretty easy to test when given the same input.\n\nThe Dojo framework comes with a [harness](https://github.com/dojo/framework/tree/master/src/testing#harness) helper, which can be used to test your widgets. You can give it a widget, and check that the virtual DOM output is what you expect.\n\n*   Does it render as expected?\n*   Does a child widget or element render as expected?\n*   Do event handlers work as expected?\n\n## Assertion Templates\n\nThe Profile widget we tested above has a property username that we can test against in the output. We could rewrite the entirety of the expected virtual DOM output for each test (that's a lot of typing) or we could create an assertion to test against that would allow us to change the expected properties on each run.\n\nLet's see how that would work.\n\nFirst, I need to update the Profile widget slightly since the `username` property is required. We can make it optional and provide a default value in the widget.\n\n```ts\n// src/widgets/Profile.ts\nexport interface ProfileProperties {\n  username?: string;\n}\n\nexport default class Profile extends WidgetBase<ProfileProperties> {\n  protected render() {\n    const { username } = this.properties;\n    return v(\"h1\", { classes: [css.root] }, [\n      `Welcome ${username || \"Stranger\"}!`\n    ]);\n  }\n}\n```\n\nThis is a little safer anyway. Now in my test, I can create my assertion template.\n\n```ts\n// tests/unit/widgets/Profile.ts\n// Add the assertionTemplate module\nimport assertionTemplate from \"@dojo/framework/testing/assertionTemplate\";\n...\n\n// Create my assertion\nconst profileAssertion = assertionTemplate(() =>\n  v(\"h1\", { classes: [css.root], \"~key\": \"welcome\" }, [\"Welcome Stranger!\"])\n);\n\ndescribe(\"Profile\", () => {\n  it(\"default renders correctly\", () => {\n    const h = harness(() => w(Profile, {}));\n    // Test against my base assertion\n    h.expect(profileAssertion);\n  });\n});\n```\n\nWe can test against our base assertion like we did before. In our assertion template, we add a `~key` property to the node so that we can update it's expected output. In a tsx file, this is called `assertion-key`.\n\nWe can now test the output if we provide a given property to the widget.\n\n```ts\n// src/tests/unit/widgets/Profile.ts\ndescribe(\"Profile\", () => {\n  it(\"default renders correctly\", () => {\n    const h = harness(() => w(Profile, {}));\n    h.expect(profileAssertion);\n  });\n\n  it(\"renders given username correctly\", () => {\n    // update the expected result with a given username\n    const namedAssertion = profileAssertion.setChildren(\"~welcome\", [\n      \"Welcome Kel Varnsen!\"\n    ]);\n    const h = harness(() => w(Profile, { username: \"Kel Varnsen\" }));\n    h.expect(namedAssertion);\n  });\n});\n```\n\nWhat the `~key` allows is for us to update that expected portion of our assertion template. So if I provide a `username`, I should expect a different welcome message. The `assertionTemplate.setChildren()` returns a new assertion template you can reference so that you don't need to reset it after each unit test, which is incredibly useful and I think is a nice touch to the library.\n\nYou can read more about assertion templates and some of its other useful methods in the [documentation](https://github.com/dojo/framework/tree/master/src/testing#assertion-templates).\n\n## Summary\n\nThis was just a quick look at testing with Dojo, but I think it highlights how useful the provided tools are for you test your widgets! Dojo tests use [intern](https://theintern.io/) by default, so you can look at the docs on how to test the business logic of your applications as well. An added benefit here is that intern provides [functional tests](https://theintern.io/docs.html#Intern/4/docs/docs%2Fwriting_tests.md/functional-tests), so you can test the behavior of your application as a user would interact with it. This would require a blog post of its own, but you can look at the [Dojo todo-mvc example](https://github.com/dojo/examples/tree/master/todo-mvc) to see how it uses functional tests.\n\nNow I know everyone is going to go out and write unit tests for all their code!\n","meta":{"title":"Testing with Dojo","date":"2019-05-06T00:00:00.000Z","author":"Rene Rubalcava","description":"How to use the testing tools of the Dojo framework","tags":"javascript, dojo, tdd, testing","cover_image":"/assets/blog/testing-with-dojo.jpg","published":true}},{"sortDate":"2019-04-24T00:00:00.000Z","file":"dojo-from-the-blocks.md","content":"---\ntitle: Dojo from the Blocks\ndate: 2019-04-24\nauthor: Rene Rubalcava\ndescription: How to use Dojo blocks during build time rendering\ntags: javascript, dojo, webdev, frameworks\ncover_image: /assets/blog/dojo-from-the-blocks.jpg\npublished: true\n---\n\nOne of the low-key features that was released in [Dojo 5](https://dojo.io/blog/2019/01/29/2019-01-29-Version-5-Dojo/) was the introduction of Blocks. Blocks go hand-in-hand with [Dojo build time rendering](https://learn-dojo.com/build-time-rendering-in-dojo/).\n\nWhat Blocks allow you to do is run some arbitrary code in a node environment during the build process.\n\n[Build time rendering](https://dev.to/odoenet/build-time-rendering-in-dojo-i6e) is a great tool you can use to generate static content without having to worry about any server side component to generate pages as requested.\n\nFor example, you could use Blocks to preprocess images that you might want loaded into your page, or maybe a more common use case of converting markdown to use for you blog or site. Blocks give you the flexibility to run code you might normally run in the server environment during your build process.\n\n## Building a block\n\nMaybe I want to build my blog on top of Dojo, and I want to just write my articles in markdown. I can use a library like [showdown](https://github.com/showdownjs/showdown) to parse my markdown files to HTML. Here is a very basic module that can do this.\n\n```ts\n// src/blocks/markdown.block.ts\nimport * as fs from 'fs';\nimport { resolve } from 'path';\n\nimport { Converter } from 'showdown';\n\nconst mdConverter = new Converter();\n\nexport default function (path: string) {\n  path = resolve(__dirname, path);\n  const file = fs.readFileSync(path, 'utf8');\n  // convert Markdown to HTML\n  const html = mdConverter.makeHtml(file);\n  return html\n};\n```\n\nBlocks are types of [metas](https://github.com/dojo/framework/tree/master/src/widget-core#meta-configuration) you can use in your widgets. I can use my block by calling the meta, and running it with with the needed arguments, like the path to the markdown file I want to parse.\n\n```ts\nimport WidgetBase from \"@dojo/framework/widget-core/WidgetBase\";\nimport { dom } from \"@dojo/framework/widget-core/d\";\nimport Block from \"@dojo/framework/widget-core/meta/Block\";\nimport { tsx } from \"@dojo/framework/widget-core/tsx\";\n\nimport fromMarkdown from \"../blocks/markdown.block\";\n\nimport * as css from \"./styles/About.m.css\";\n\nexport default class About extends WidgetBase {\n  protected render() {\n    const node = document.createElement(\"div\");\n    // Use my block\n    const message = this.meta(Block).run(fromMarkdown)(\n      \"../../markdown/post2.md\"\n    );\n    node.innerHTML = message;\n    // Create a vnode to inject my HTML\n    const vnode = dom({ node });\n    return (\n      <div>\n        <h1 classes={css.root}>About Page</h1>\n        {vnode}\n      </div>\n    );\n  }\n}\n```\n\nI can now naively inject my parsed markdown as HTML into my page. Ideally, I would like to convert that HTML into real virtual dom nodes, but I haven't gotten that far yet.\n\nYou can quickly see how useful this would be during build time to process files, maybe pull in some external files and use them in an app.\n\n## Image processing\n\nIn my app, I might have some images that I want to convert to base64 strings so I can embed them. I can use a tool like [sharp](https://github.com/lovell/sharp) to resize my images. When I do, I can go ahead create the virtual dom nodes and return them in my block.\n\n```ts\n// src/blocks/imagebase64.block.ts\nimport { resolve } from 'path';\nimport { v } from '@dojo/framework/widget-core/d';\nimport * as sharp from 'sharp';\n\nexport default async function (path: string) {\n  path = resolve(__dirname, path);\n  // resize my images\n  const images = [\n    await sharp(path).resize(200).toBuffer(),\n    await sharp(path).resize(300).toBuffer(),\n    await sharp(path).resize(400).toBuffer(),\n    await sharp(path).resize(500).toBuffer()\n  ];\n\n  return images.map((a) =>\n    v('img', { src: `data:image/jpeg;base64, ${a.toString('base64')}`, alt: 'my dog sally' })\n  );\n};\n```\n\nYou might notice, that I'm able to run asynchronous tasks inside my block. This allows me to do some more interesting things like image processing, fetching data, or maybe run some sort of analysis on a dataset to create formatted json that can be used by a charting library! I'm just throwing out some ideas here!\n\n## Summary\n\nYou can view the source code for this sample [here](https://github.com/odoe/learning-dojo-blocks), and you can view a live demo [here](https://learning-dojo-blocks.surge.sh).\n\nDojo Blocks are really interesting, and I think they provide a whole new level of functionality for developers taking advantage of build time rendering with Dojo. I don't see a reason not to use build time rendering, and Blocks offer you a whole new opportunity to get crazy about it. I'm currently looking at a rewrite of my blog with Dojo using them!\n\n","meta":{"title":"Dojo from the Blocks","date":"2019-04-24T00:00:00.000Z","author":"Rene Rubalcava","description":"How to use Dojo blocks during build time rendering","tags":"javascript, dojo, webdev, frameworks","cover_image":"/assets/blog/dojo-from-the-blocks.jpg","published":true}},{"sortDate":"2019-04-18T00:00:00.000Z","file":"maintain-state-with-dojo-stores.md","content":"---\ntitle: Maintain State with Dojo Stores\ndate: 2019-04-18\nauthor: Rene Rubalcava\ndescription: How to use Dojo Stores to maintain state across your applications.\ntags: javascript, dojo, typescript, webdev\ncover_image: /assets/blog/maintain-state-with-dojo-stores.jpg\npublished: true\n---\n\nWe previously looked at how you could maintain state with [Dojo containers](https://learn-dojo.com/dojo-containers/) using a context for your application. To recap, containers are basically higher order components that you can use to add state management to widgets.\n\nUsing a context with containers makes the process fairly simple, however if you want to wire up multiple containers and routes with shared state, you might want to start looking at using [Dojo Stores](https://github.com/dojo/framework/tree/master/src/stores).\n\nDojo Stores work by using [Processes](https://github.com/dojo/framework/tree/master/src/stores#processes) to execute [Commands](https://github.com/dojo/framework/tree/master/src/stores#commands) with varying [Operations](https://github.com/dojo/framework/tree/master/src/stores#operations) against your state. You don't need to define your operations, Dojo provides them for you. These operations are based on the [JSON Patch format](http://jsonpatch.com/). They currently support add, remove, replace, and test. If you're not familiar with these operations or they look intimidating, don't worry, they are much simpler than they may seem at first.\n\nIn order to try and grasp how everything works, let's create a small application that explores the [Star Wars API](https://swapi.co/).\n\n## API Explorer Widget\n\nFirst thing we'll do is create a widget that can explore the API. I'll use a [Listbox](https://github.com/dojo/widgets/tree/master/src/listbox) to display the endpoints of the API and a [TextArea](https://github.com/dojo/widgets/tree/master/src/text-area) to display the raw JSON results of the selected endpoint.\n\n```tsx\n// src/widgets/APIExplorer.tsx\nimport { tsx } from \"@dojo/framework/widget-core/tsx\";\nimport { WidgetBase } from \"@dojo/framework/widget-core/WidgetBase\";\nimport { watch } from \"@dojo/framework/widget-core/decorators/watch\";\nimport Listbox from \"@dojo/widgets/listbox\";\nimport TextArea from \"@dojo/widgets/text-area\";\nimport theme from \"@dojo/themes/dojo\";\nimport * as css from \"./styles/APIExplorer.m.css\";\n\nimport { ExplorerProperties, Item } from \"../interfaces\";\n\nexport class APIExplorer extends WidgetBase<ExplorerProperties> {\n  @watch() index = 0;\n  @watch() label = \"\";\n\n  onAttach() {\n    this.properties.fetchAllResults();\n  }\n  protected render() {\n    return (\n      <div classes={css.root}>\n        <Listbox\n          theme={theme}\n          key=\"listbox1\"\n          activeIndex={this.index}\n          widgetId=\"listbox1\"\n          optionData={this.properties.items}\n          getOptionLabel={(option: Item) => option.label}\n          getOptionSelected={(option: Item) => option.label === this.label}\n          onActiveIndexChange={(index: number) => {\n            this.index = index;\n          }}\n          onOptionSelect={(option: Item, index: number) => {\n            this.label = option.label;\n            this.properties.fetchData(option);\n          }}\n        />\n        <TextArea rows={15} theme={theme} value={this.properties.result} />\n      </div>\n    );\n  }\n}\n\n// src/interfaces.ts\nexport interface ExplorerProperties {\n  items: Item[];\n  result: string;\n  fetchAllResults: () => void;\n  fetchData: (item: Item) => void;\n}\n```\n\nThis widget has some local state to manage the selected value of the Listbox, but other than that, it relies on the properties passed to it in order to display anything useful. I'll be using a container to pass those properties to this widget. But first, how would I make my queries and actually update my application state in the first place?\n\n## Processes\n\nProcesses are used to execute commands against your application store. It's in the processes that you are going to be doing most of the heavy lifting for your application. This is where you can do queries, transformations, filtering, validation, and so on. There are factory functions in Dojo to help you create your commands.\n\n```ts\n// src/processes/starwarsProcesses.ts\nimport {\n  createProcess,\n  createCommandFactory\n} from \"@dojo/framework/stores/process\";\nimport { replace } from \"@dojo/framework/stores/state/operations\";\n\nimport { State, Item } from \"../interfaces\";\n\n// commandFactory typed to my application state\nconst commandFactory = createCommandFactory<State>();\n```\n\nIn this application, I'm going to use the **replace** operation to make my state updates. If I were adding items to an array in my commands, I could do some interesting things using the **at** helper and **add** operation to insert new items into an array _at_ specific indices.\n\nLet me create a command that will fetch all the available endpoints of the Star Wars API.\n\n```ts\n// src/processes/starwarsProcesses.ts\nconst fetchItems = commandFactory<Item>(async ({ path }) => {\n  const response = await fetch(\"https://swapi.co/api/\");\n  const json = await response.json();\n  const items: Item[] = Object.keys(json).map(key => {\n    return {\n      label: key,\n      value: json[key]\n    };\n  });\n  return [replace(path(\"items\"), items)];\n});\n```\n\nI use my command factory to create a function that will make my query and then returns an array of operations. Why any array? Because I may want a single command do multiple state updates. In this case I use **[replace(path(\"items\"), items)]**. This may look odd at first, but the path method is a way to designate a property path in my state. If I want to use the value from my state I could use a _get_ helper and write **get(path(\"items\"))**, which would return the items array.\n\nI was unsure how I felt about this method of accessing state at first, but it lends itself very well to a functional and reactive method of interacting with state that has really grown on me. This behavior is very much like working with [lenses](https://medium.com/javascript-scene/lenses-b85976cb0534).\n\nNow, I'll create a command to fetch the results of one of the selected endpoints.\n\n```ts\n// src/processes/starwarsProcesses.ts\nconst fetchResult = commandFactory<Item>(async ({ path, payload }) => {\n  const response = await fetch(payload.value);\n  const result = await response.json();\n  return [replace(path(\"result\"), JSON.stringify(result, undefined, 2))];\n});\n```\n\nVery similar to the previous command I am going to fetch the results of an endpoint, but that endpoint URL is coming from a **payload** object that was passed to my command. I've typed this payload to have a **value** property, but it will be any argument that has been passed to the process that will execute this command. We'll see how that is done in a moment, but first we need to create a couple of processes that will be used to execute these commands.\n\n```ts\n// src/processes/starwarsProcesses.ts\nexport const fetchItemsProcess = createProcess(\"fetch-items\", [fetchItems]);\nexport const fetchResultProcess = createProcess(\"fetch-result\", [fetchResult]);\n```\n\nWe create two processes to do two distinct operations on my state. What I find interesting here is that I can have a single process execute multiple commands that could in turn perform multiple operations against my state. I haven't done this yet, but I find the fact that _I could_ to be awesome!\n\n## Container\n\nLet's wrap our widget in a container that will use our processes to wire up properties and methods.\n\n```ts\n// src/containers/APIExplorerContainer.ts\nimport { Store } from \"@dojo/framework/stores/Store\";\nimport { StoreContainer } from \"@dojo/framework/stores/StoreInjector\";\nimport { APIExplorer } from \"../widgets/APIExplorer\";\n\nimport { State } from \"../interfaces\";\n\nimport {\n  fetchItemsProcess,\n  fetchResultProcess\n} from \"../processes/starwarsProcesses\";\n\nfunction getProperties(store: Store<State>): any {\n  const { get, path } = store;\n\n  return {\n    items: get(path(\"items\")),\n    result: get(path(\"result\")),\n    fetchAllResults: fetchItemsProcess(store),\n    fetchData: fetchResultProcess(store)\n  };\n}\n// Use a StoreContainer\nexport const APIExplorerContainer = StoreContainer(\n  APIExplorer,\n  \"state\",\n  { getProperties }\n);\n```\n\nWe are using a specific container called a **StoreContainer** that will inject our store in to our **getProperties** method. This method is how you can pass properties to your wrapped widget from the container.\n\nYou can see here that the store has helper methods, **get** and **path**, that I mentioned before to access the values of properties on the store. I can now pass processes that will execute commands against the store as methods that my widget is expecting as part of its properties.\n\nOnce this is done, I need to register my store with my application and inject it.\n\n```tsx\n// src/main.tsx\nconst store = new Store();\nconst registry = registerStoreInjector(store);\n\nclass App extends WidgetBase {\n  protected render() {\n    return <APIExplorerContainer />;\n  }\n}\n\nconst r = renderer(() => <App />);\nr.mount({ registry });\n```\n\nI use a helper called **registerStoreInjector** and then inject that store into a named state that I used in my container.\n\n[Code Sandbox](https://codesandbox.io/s/7m9q47yvj?fontsize=14&module=%2Fsrc%2Fprocesses%2FstarwarsProcesses.ts)\n\n\n## Summary\n\nThere is a lot happening here, but what it boils down to is the following steps.\n\n*   Create processes to execute commands against a Store\n*   Wrap widget in a container to pass processes and store properties\n*   Inject store into application\n\nAny subsequent updates the store will be passed down to the widget. There is even more you could do with your store. I could have wrapped my widget in a [StoreProvider](https://github.com/dojo/framework/tree/master/src/stores#advanced) and passed store properties down, and manually [subscribe to store changes](https://github.com/dojo/framework/tree/master/src/stores#subscribing-to-store-changes). Subscribing to store changes could be a very useful tool inside your applications for some granular control of managing widget visibility for example.\n\nProcesses even provide the ability to add [middleware](https://github.com/dojo/framework/tree/master/src/stores#middleware) so you can add logging and authentication, or maybe payload validation without having to pollute your processes with extra code and possibly extra sources of errors.\n\nAt the end of the day, I have had a fun time learning how to use processes and stores in my applications. They provide a lot of flexibility in managing state and I can already see how useful they would be in building out an application as it grows!","meta":{"title":"Maintain State with Dojo Stores","date":"2019-04-18T00:00:00.000Z","author":"Rene Rubalcava","description":"How to use Dojo Stores to maintain state across your applications.","tags":"javascript, dojo, typescript, webdev","cover_image":"/assets/blog/maintain-state-with-dojo-stores.jpg","published":true}},{"sortDate":"2019-04-08T00:00:00.000Z","file":"style-dojo-widgets.md","content":"---\ntitle: Style Dojo Widgets\ndate: 2019-04-08\nauthor: Rene Rubalcava\ndescription: How to style the out-of-the-box Dojo widgets\ntags: javascript,dojo,webdev\ncover_image: /assets/blog/style-dojo-widgets.jpg\npublished: true\n---\n\nThere's an entire Dojo tutorial on [creating custom themes](https://dojo.io/tutorials/007_theming/), and if you look at any of the guides on creating widgets you will learn how to create css modules to use with your widgets and your applications.\n\nBut how about if you want to use some of the [out-of-the-box widgets with Dojo?](https://github.com/dojo/widgets) There is an entire library of ready to use widgets you can start building off for your applications today. We saw this when we created a [datepicker](https://learn-dojo.com/creating-a-datepicker-with-dojo/), and there's even widgets like [select](https://github.com/dojo/widgets/tree/master/src/select) and [button](https://github.com/dojo/widgets/tree/master/src/button). Check out the [widget showcase](https://dojo.github.io/examples/widget-showcase/) for more!\n\nIf you just wanted to quickly get started with a nice looking theme, you can use the [Dojo theme](https://github.com/dojo/themes). I'll cover how to create your own themes another time, but for now, let's assume you have a Dojo widget in your application and you really like the Dojo theme, but you would like to slightly make some adjustments. Not enough to warrant a custom theme, but maybe add some italic font, change a background here and there.\n\nDojo provides a way to do this in a [CSS modules](https://css-tricks.com/css-modules-part-1-need/) friendly manner. Every widget has a section in its documentation on the CSS classes you can override, such as those in the [select widget](https://github.com/dojo/widgets/tree/master/src/select#theming). To get started, let's add the Dojo theme to this widget.\n\n```ts\nimport theme from \"@dojo/themes/dojo\";\n...\n\n// in your render method\n<Select\n  theme={theme} // apply the Dojo theme\n  options={names}\n  value={this.selectedValue}\n  placeholder=\"Pick a name\"\n  onChange={this.onSelectChange}\n/>\n```\n\nAt this point, you're able use a nice looking theme provided by Dojo. However, maybe I would like the placeholder text to be italicized, and I'd like to change the background color of the button and some other colors a bit. I don't want to change much, just a few things.\n\n\n```css\n.arrow {\n  background: #959595;\n  color: #fff;\n}\n\n.focused {\n  color: #005e95;\n}\n\n.placeholder {\n  font-style: italic;\n}\n\n.inputWrapper {\n  color: #6e6e6e;\n}\n```\n\nNow I have some simple CSS that matches the class names in the [documentation](https://github.com/dojo/widgets/tree/master/src/select#theming). You can now apply these class names to your Select widget using a plain old JavaScript object that will map the extra classes to the widget key. You can see more detail [here](https://github.com/dojo/framework/tree/master/src/widget-core#styling--theming).\n\n\n```ts\nconst SelectClasses = {\n  \"@dojo/widgets/select\": {\n    arrow: \\[css.arrow\\],\n    focused: \\[css.focused\\],\n    placeholder: \\[css.placeholder\\],\n    inputWrapper: \\[css.inputWrapper\\]\n  }\n};\n\n// in your render method\n<Select\n  theme={theme} // apply the Dojo theme\n  classes={SelectClasses}\n  options={names}\n  value={this.selectedValue}\n  placeholder=\"Pick a name\"\n  onChange={this.onSelectChange}\n/>\n```\n\nThis will now maintain the Dojo theme you are already using, but also apply the classes you are adding the widget as well. You end up with an application that looks something like below.\n\n[Code Sandbox](https://codesandbox.io/embed/lp3xl1x2om?fontsize=14&amp;module=%2Fsrc%2Fwidgets%2FHello.tsx)\n\nAs you can see, it doesn't take a lot of work to use the provided Dojo theme with your applications and apply your own little CSS sugar to the out-of-the-box Dojo widgets. You can also take this a step further and create your own [custom theme](https://dojo.io/tutorials/007_theming/) for your application and even a [reusable theme](https://github.com/dojo/cli-create-theme) for a suite of applications! Happy dev'ing!\n\n","meta":{"title":"Style Dojo Widgets","date":"2019-04-08T00:00:00.000Z","author":"Rene Rubalcava","description":"How to style the out-of-the-box Dojo widgets","tags":"javascript,dojo,webdev","cover_image":"/assets/blog/style-dojo-widgets.jpg","published":true}},{"sortDate":"2019-04-08T00:00:00.000Z","file":"building-a-simple-app-in-dojo.md","content":"---\ntitle: Building a simple app in Dojo\ndate: 2019-04-08\nauthor: Rene Rubalcava\ndescription: How to build a basic app in Dojo, but not hello world!\ntags: javascript, typescript, dojo, webdev\ncover_image: /assets/blog/building-a-simple-app-in-dojo.jpg\npublished: true\n---\n\nI've been thinking about how I could demonstrate building a basic Dojo application beyond a hello world app or a Todo app. There are some really good samples in the [dojo/examples](https://github.com/dojo/examples) repo. Then I came across [this react application](https://github.com/ahfarmer/emoji-search) for searching for emojis and who doesn't have to search for emojis regularly, so I knew I found my demo. It also helps that the dojo template on [Code Sandbox](https://codesandbox.io/) now uses TSX/JSX as the default.\n\nBecause the dojo template app uses JSX by default, it made this sample almost a complete one to one of the react sample. I won't go into detail of this application line by line, but I do want to cover some core concepts it shows.\n\n### Get Meta\n\nMeta in Dojo is _meta information_ about your widget. Pretty meta right?\n\nWhen you build Dojo widgets, you never touch the output HTML of your application. There is no widget method to get a reference to the DOM. This prevents you from inadvertently changing a DOM element that is referenced by Dojos virtual DOM engine, which would be bad. So don't get too crazy here. But there are valid reasons for wanting to access a DOM node in your application. In the case of my emoji application, I am using a small library called [clipboardjs](https://clipboardjs.com/) to let me copy emojis to my clipboard from my application. This library requires I pass a DOM node it will use to copy data to the clipboard.\n\nYou can get this information in Dojo is via a [meta](https://dojo.io/docs/index.html#doc--dojo__framework__v5_0_1__src__widget-core__README_md___meta-configuration). Dojo provides some metas out of the box for you, like [Dimensions](https://dojo.io/docs/index.html#doc--dojo__framework__v5_0_1__src__widget-core__README_md___dimensions), [Animations](https://dojo.io/docs/index.html#doc--dojo__framework__v5_0_1__src__widget-core__README_md___animations), [Intersection](https://dojo.io/docs/index.html#doc--dojo__framework__v5_0_1__src__widget-core__README_md___intersection), and more. You can implement your own custom meta to access DOM nodes using `@dojo/framework/widget-core/meta/Base`.\n\n```tsx\n// src/widgets/ElementMeta.ts\nimport { Base as MetaBase } from \"@dojo/framework/widget-core/meta/Base\";\n\nclass ElementMeta extends MetaBase {\n  get(key: string): Element {\n    const node = this.getNode(key);\n    return node as Element;\n  }\n}\n\nexport default ElementMeta;\n```\n\nThe meta implements a `get()` method that will get the DOM node via a given key and return that DOM node. Now in my application, where I use clipboardjs, I can use my meta in combination with the `this.meta()` method of the Widget to get a referenced DOM node.\n\n```tsx\n// src/widgets/EmojiResultsRow.tsx\nimport { tsx } from \"@dojo/framework/widget-core/tsx\";\nimport { WidgetBase } from \"@dojo/framework/widget-core/WidgetBase\";\n\nimport * as css from \"./styles/EmojiResultsRow.m.css\";\n\nimport ElementMeta from \"./ElementMeta\";\nimport * as Clipboard from \"clipboard\";\n\nexport interface EmojiResultsRowProperties {\n  title: string;\n  symbol: string;\n}\n\nexport class EmojiResultsRow extends WidgetBase<EmojiResultsRowProperties> {\n  clipboard: Clipboard = null;\n\n  onAttach() {\n    // use my meta to get a DOM node\n    const element = this.meta(ElementMeta).get(this.properties.title);\n    this.clipboard = new Clipboard(element);\n  }\n  onDetach() {\n    this.clipboard.destroy();\n  }\n\n  protected render() {\n    const { title, symbol } = this.properties;\n    const codePointHex = symbol.codePointAt(0).toString(16);\n    const src = `//cdn.jsdelivr.net/emojione/assets/png/${codePointHex}.png`;\n    // provide a `key` property to my widget element to\n    // reference with my meta\n    return (\n      <div\n        key={title}\n        classes={[css.root, \"copy-to-clipboard\"]}\n        data-clipboard-text={symbol}\n      >\n        <img alt={title} src={src} />\n        <span classes={[css.title]}>{title}</span>\n        <span classes={[css.info]}>Click to copy emoji</span>\n      </div>\n    );\n  }\n}\n\nexport default EmojiResultsRow;\n```\n\nNow I am able to use my custom meta to get a DOM node created by my widget. This makes access to output DOM nodes flexible, but also protects me from shooting myself in the foot unintentionally. If I break my DOM, it is totally my fault now.\n\n### Core Widgets\n\nDojo provides a suite of [widgets](https://github.com/dojo/widgets/) you can use for your own applications. This includes items like [TimePicker](https://github.com/dojo/widgets/blob/master/src/time-picker/README.md), [Select](https://github.com/dojo/widgets/blob/master/src/select/README.md) and [layout widgets](https://github.com/dojo/widgets/#layout-widgets). For my application, I'm interested in having an input that I can use for search. Every time I update the input element, I want to filter the list of emojis shown in my application. So I'm going to wrap a [TextInput](https://github.com/dojo/widgets/blob/master/src/text-input/README.md) widget so I can manage some local state and pass the value of the input to a filter method.\n\n```tsx\n// src/widgets/SearchInput.tsx\n...\nexport class SearchInput extends WidgetBase<SearchInputProperties> {\n  @watch() private searchValue = \"\";\n\n  private onChange(value) {\n    if (!value) {\n      return;\n    }\n    this.searchValue = value;\n    const { handleChange } = this.properties;\n    handleChange(value);\n  }\n\n  protected render() {\n    return (\n      <div classes={[css.root]}>\n        <div>\n          <TextInput\n            placeholder=\"Search for emoji\"\n            value={this.searchValue}\n            onInput={this.onChange}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n```\n\nYes, I could have used a regular `<input type=\"text\" />` here, but the TextInput is very convenient as it already has an `onInput` method I can use that passes the value of the input directly, and not an event I would need to do `event.target.value` which, because I am lazy, I can really appreciate. Then I would need to use a `keyup` event, and maybe do some handling for different keys to on whether I want to get my value and why hassle with all that when Dojo provides a nice way to do it already.\n\nI am also taking advantage of the [`@watch`](https://dojo.io/docs/index.html#doc--dojo__framework__v5_0_1__src__widget-core__README_md___internal-widget-state) decorator to manage local state in my widget. I talked about this method in more detail [here](https://learn-dojo.com/watch-for-property-changes-in-widgets/). This makes it very simple to manage the value of my input at all times.\n\nYou can see the full application in action [here](https://codesandbox.io/embed/9lpj1zmyw).\n\nYou can see that building applications in Dojo provides some safety and flexibility for you to piece together everything you need to build solid, and awesome applications. Dojo isn't just a toolkit anymore, it's a full blown framework and has a lot to offer!\n","meta":{"title":"Building a simple app in Dojo","date":"2019-04-08T00:00:00.000Z","author":"Rene Rubalcava","description":"How to build a basic app in Dojo, but not hello world!","tags":"javascript, typescript, dojo, webdev","cover_image":"/assets/blog/building-a-simple-app-in-dojo.jpg","published":true}},{"sortDate":"2019-03-15T00:00:00.000Z","file":"build-time-rendering-in-dojo.md","content":"---\ntitle: Build Time Rendering in Dojo\ndate: 2019-03-15\nauthor: Rene Rubalcava\ndescription: Quick look at how to use Build Time Rendering with Dojo\ntags: javascript, web development, dojo\ncover_image: /assets/blog/build-time-rendering-in-dojo.jpg\npublished: true\n---\n\nYou may have worked with other frameworks that support server side rendering. What it basically does is render the HTML of your page and pass it down to the client as it would look when the initial JavaScript loads and then you can interact with it and the JavaScript stuff works its _magic_ to make a cool interactive application.\n\nThe Dojo method of doing this is much simpler. Instead of rendering the pages on the server, you can create your pages during the build process, and then you can just upload it anywhere.\n\nYou can find some information about Build Time Rendering on the github page for [dojo/cli-build-app](https://github.com/dojo/cli-build-app#build-time-renderbtr-object). You can get started by using the [dojo/cli](https://github.com/dojo/cli) to quickly scaffold an application and modify it a bit.\n\nOnce you have your template application ready to go, let's make some modifications. First thing we need to do in `src/index.html` is add a root div that the build time rendering tools can work with.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en-us\">\n<head>\n  <title>dojo-btr</title>\n  <meta name=\"theme-color\" content=\"#222127\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n</head>\n<body>\n  <div id=\"root\"></div> <!-- Add this element -->\n</body>\n</html>\n```\n\nNow we can set up the configuration for build time rendering. One thing to note is that by default, the template application uses hash routing, meaning that routes look like `myapp/#about`. This will generate a single index.html file in your build that will quickly load those routes. If you use a different [history manager](https://github.com/dojo/framework/tree/master/src/routing#router), it will create an _index.html_ for each route.\n\n```json\n{\n  \"build-app\": {\n    \"build-time-render\": {\n      \"root\": \"root\",\n      \"paths\": [\n        \"#home\",\n        \"#about\",\n        \"#profile\"\n      ]\n  }\n}\n```\n\nNote that I have prefixed my paths with a `#` so that the BTR can generate the pages correctly. The output of this is pretty interesting. Each route is stored in an array as strings, and as you change your route at runtime, it will load the HTML of that route as needed.\n\nThe benefit here is that your HTML is ready to go and the JavaScript parts just do their thing without having to do an initial render of your page. It makes for a very responsive experience. You get a lot of benefit from Build Time Rendering with some simple configuration, so take advantage of it!\n\nYou can see a sample of how this looks in a sample application I put together [here](https://github.com/odoe/dojo-btr). I also have it running live [here](https://learn-dojo-btr-demo.netlify.com).\n\n","meta":{"title":"Build Time Rendering in Dojo","date":"2019-03-15T00:00:00.000Z","author":"Rene Rubalcava","description":"Quick look at how to use Build Time Rendering with Dojo","tags":"javascript, web development, dojo","cover_image":"/assets/blog/build-time-rendering-in-dojo.jpg","published":true}},{"sortDate":"2019-01-22T00:00:00.000Z","file":"intro-to-the-dojo-router.md","content":"---\ntitle: Intro to the Dojo Router\ndate: 2019-01-22\nauthor: Rene Rubalcava\ndescription: An Introduction to using the Dojo Router for scalable apps\ntags: javascript, typescript, dojo, webdev\ncover_image: /assets/blog/intro-to-the-dojo-router.jpg\npublished: true\n---\n\n\nWe took a quick look at the Dojo router when we [reviewed the template application](https://learn-dojo.com/dojo-cli-template-app/) from the dojo cli. The template application provides almost everything you need to know about the Dojo router. But lets take a little deeper look at [routing](https://dojo.io/tutorials/1030_routing/).\n\n## Defining Routes\n\nThe template application does a great job of providing a clear way to configure your routes.\n\n```ts\n// src/routes.ts\nexport default [\n  {\n    path: \"home\",\n    outlet: \"home\",\n    defaultRoute: true\n  },\n  {\n    path: \"about\",\n    outlet: \"about\"\n  },\n  {\n    path: \"profile/{username}\",\n    outlet: \"profile\"\n  }\n];\n```\n\nThe routes are defined as an array of objects. each Route object has a [RouteConfig interface](https://github.com/dojo/framework/blob/master/src/routing/interfaces.d.ts) with properties you can define. In the snippet above I have made one change. I have set the path for the profile route as **profile/{username}**. This means I will need to define a parameter to that route, which well get to in a moment, but first lets look at the options for a route config.\n\n```ts\n// dojo/framework/src/routing/interfaces.d.ts\nexport interface RouteConfig {\n  path: string;\n  outlet: string;\n  children?: RouteConfig[];\n  defaultParams?: Params;\n  defaultRoute?: boolean;\n}\n```\n\nThats the beauty of working with TypeScript and Dojo, you can look at the types and interfaces of the code and use them as a guide as to how you should use the tools. The only required properties are path and outlet. One of the other properties we see defined in our configuration is the defaultRoute, which as you may have guessed is the default route of your application. Who says naming things is hard?!\n\nThe children property would be used if you had nested routes. You could also define some default parameters, which is really useful if you have a route the depends on parameters, and your route needs them to behave correctly.\n\n## Outlet\n\nThe first part of routing we need to look at is the [Outlet](https://dojo.io/docs/index.html#doc--dojo__framework__v4_0_0__src__routing__README_md___outlets). The Outlet is a higher order component that you use to wrap up widgets that are part of a designated route.\n\n```ts\n// src/App.ts\n...\nexport default class App extends WidgetBase {\n  protected render() {\n    return v(\"div\", { classes: [css.root] }, [\n      w(Menu, {}),\n      v(\"div\", [\n        // Outlet is where routes go\n        // the decide which widgets\n        // match each route\n        w(Outlet, {\n          key: \"home\",\n          id: \"home\",\n          renderer: () => w(Home, {})\n        }),\n        w(Outlet, {\n          key: \"about\",\n          id: \"about\",\n          renderer: () => w(About, {})\n        }),\n        w(Outlet, {\n          key: \"profile\",\n          id: \"profile\",\n          renderer: () => w(Profile, { username: \"Dojo User\" })\n        })\n      ])\n    ]);\n  }\n}\n```\n\nLooking at the outlet, you can see that we define the id of the Outlet to match the Route configuration we defined. The actual widget rendered in the Route doesnt have to match the id, but as you can see, its pretty good practice to do so. Keep the code readable please.\n\nOutlets are pretty straightforward. Since they render the widget for a Route, they can also handle passing any URL parameters as properties to the widget.\n\n## Link and Parameters\n\nBefore we dive in to URL parameters, first we need to talk about how you can create a link to a route that is expecting parameters. We can define those parameters with a specific component in Dojo for working with routes, the [Link](https://dojo.io/docs/index.html#doc--dojo__framework__v4_0_0__src__routing__README_md___link) component.\n\n```ts\n// src/widgets/Menu.ts\nw(\n  Link,\n  {\n    to: 'profile',\n    key: 'profile',\n    classes: [css.link],\n    activeClasses: [css.selected],\n    params: {\n      username: 'odoe'\n    }\n  },\n  ['Profile']\n)\n```\n\nThe Link component is designed specifically for creating links to routes and static paths in your application. They provide some sugar to regular anchor tags you can take advantage of in your apps. In this case, I am providing a value to the **username** parameter we defined for our route. This means that is will pass the object **{ username: odoe }** to my Outlet that I can then use to pass to my child widget.\n\n```ts\n// src/App.ts\nw(Outlet, {\n  key: 'profile',\n  id: 'profile',\n  renderer: ({ params }: MatchDetails) => {\n    return w(Profile, { username: params.username });\n  }\n})\n```\n\nWhen you pass parameters to a URL in the Dojo router, your render method is passed the parameters for you to use in your application as needed. Now, although this method works fine, you can be more explicit in how you use your route parameters.\n\nYou can define query parameters in your routes and use them for more advanced usage. Lets update the route configuration.\n\n```ts\n// src/routes.ts\nexport default [\n  ...\n  {\n    path: \"profile/{param}?{value}\",\n    outlet: \"profile\"\n  }\n];\n```\n\nMaybe we have different ways of searching for users in our backend API. We can search by name or id,.\n\n\n```ts\n// src/widgets/Menu.ts\nw(\n  Link,\n  {\n    to: 'profile',\n    key: 'profile',\n    classes: [css.link],\n    activeClasses: [css.selected],\n    params: {\n      param: 'name',\n      value: 'odoe'\n    }\n  },\n  ['Profile']\n)\n```\n\nNow we can update our Outlet to pass the correct information to the child widget.\n\n```ts\n// src/App.ts\nw(Outlet, {\n  key: 'profile',\n  id: 'profile',\n  renderer: ({ params, queryParams }: MatchDetails) => {\n    const user = users.find((user: User) => {\n      return user[params.param] == queryParams.value;\n    }) as User;\n    return w(Profile, { username: `${user.name} ${user.lastName}` });\n  }\n})\n```\n\nNow we have built a fairly generic way of passing parameters and values to our Outlet and being able to search for the correct username to use in our widget. We can search by the **name** value or an **id** value.\n\n## Default Parameters\n\nSo far we have been defining parameters in our Link, but maybe we want to define some default parameters directly in our route instead.\n\n```ts\n// src/routes.ts\nexport default [\n  ...\n  {\n    path: 'profile/{param}?{value}',\n    outlet: 'profile',\n    defaultParams: {\n      param: 'id',\n      value: '2'\n    }\n  }\n];\n```\n\nFor out default route, we can decide to search by id with a value of 2. When you start dealing with URL parameters, everything is a string, so if you wanted to use real numbers, you would need to do some additional sanitization in your application, but I think weve dived pretty deep into setting up the Dojo router for starter use. Big thanks to [Anthony Gubler](https://twitter.com/agubler_) for helping me out with some of my router questions, it was a big help.\n\n## Summary\n\nAs you can see, the Dojo router is very flexible in how you want to define your routes and parameters. Depending on how your backend APIs are defined, you could create some very powerful and scalable applications!\n\n","meta":{"title":"Intro to the Dojo Router","date":"2019-01-22T00:00:00.000Z","author":"Rene Rubalcava","description":"An Introduction to using the Dojo Router for scalable apps","tags":"javascript, typescript, dojo, webdev","cover_image":"/assets/blog/intro-to-the-dojo-router.jpg","published":true}},{"sortDate":"2019-01-09T00:00:00.000Z","file":"intro-to-the-dojo-registry.md","content":"---\ntitle: Intro to the Dojo Registry\ndate: 2019-01-09\nauthor: Rene Rubalcava\ndescription: An introduction to managing widgets with the Dojo Registry\ntags: dojo, javascript, web development\ncover_image: /assets/blog/intro-to-the-dojo-registry.jpg\npublished: true\n---\n\nThe [Dojo Registry](https://dojo.io/docs/index.html#doc--dojo__framework__v4_0_0__src__widget-core__README_md___registry) is a powerful way you can work with widgets in your applications. We've had the opportunity to touch on the Registry in previous posts. We used it to inject context into our application with [Dojo Containers](https://learn-dojo.com/dojo-containers/) and it's also used when you want to use [routing](https://learn-dojo.com/dojo-cli-template-app/) in your applications.\n\n### Basic Registry\n\nThe Registry allows you to do a few different things in your application. You can register widgets with the registry as string values and then reference the string values anywhere throughout your app.\n\nFor example, maybe I want to define a string value for an AboutMe widget used in my About page.\n\n```ts\n// src/main.ts\nimport Registry from '@dojo/framework/widget-core/Registry';\n...\n// define widgets\nimport AboutMe from './widgets/AboutMe';\n\nconst registry = new Registry();\nregistry.define('about-me', AboutMe);\n\n// src/widgets/About.ts\nimport WidgetBase from '@dojo/framework/widget-core/WidgetBase';\nimport { w, v } from '@dojo/framework/widget-core/d';\n\nimport * as css from './styles/About.m.css';\n\nexport default class About extends WidgetBase {\n  protected render() {\n    return v('h1', { classes: [css.root] }, [\n      'About Page',\n      // can reference the string value\n      // of widget without importing it\n      w('about-me', {}, [])\n    ]);\n  }\n}\n```\n\nThis is pretty useful, as it can keep some of your widget code clean and you can define a series of widgets in a single location as you register them. Things start to get really interesting when we use the local registry of the widget to handle lazy loading via a [registry decorator](https://dojo.io/docs/index.html#doc--dojo__framework__v4_0_0__src__widget-core__README_md___registry-decorator).\n\n## Registry Decorator\n\nEach widget has it's own local registry that you can use to lazy load a widget until you need it. Maybe I want to have a button on my page that when clicked will load some other widget in its place. For the cli template application, maybe I have some profile information I want to show.\n\n```ts\n// src/widgets/MyProfile.ts\nimport WidgetBase from '@dojo/framework/widget-core/WidgetBase';\nimport { v } from '@dojo/framework/widget-core/d';\n\nexport default class MyProfile extends WidgetBase {\n  protected render() {\n    return v('aside', {}, [\n      v('p', {}, [\n        `I don't believe in the moon,\n         I think it's just the back of the sun.`\n      ])\n    ]);\n  }\n}\n```\n\nThis is a simple little widget, nothing too fancy. Now let's add it to our profile widget with the registry decorator.\n\n```ts\n// src/widgets/Profile.ts\nimport { registry } from '@dojo/framework/widget-core/decorators/registry';\nimport { watch } from '@dojo/framework/widget-core/decorators/watch';\n\n...\n\n// the decorator allows us to use a dynamic import\n// to lazy load this widget until it's needed\n@registry('my-profile', () => import('./MyProfile'))\nexport default class Profile extends WidgetBase<ProfileProperties> {\n  @watch() private _showProfile = false;\n\n  private onButtonClick() {\n    this._showProfile = true;\n  }\n\n  protected render() {\n    const { username } = this.properties;\n    // check if the `_showProfile` property\n    // is true to determine if I should load\n    // the `MyProfile` widget\n    const node = this._showProfile ?\n                  w('my-profile', {}) :\n                  v('button', {\n                    onclick: this.onButtonClick\n                    }, [ 'Show Profile' ]);\n    return v('h1', { classes: [css.root] }, [\n      `Welcome ${username}!`,\n      v('p', {} , [\n        node\n      ])\n    ]);\n  }\n}\n```\n\nWe can take advantage of the watch decorator to update a value of our widget to determine what our widget should look like. You can read more about the watch decorator in my [previous blog post](https://learn-dojo.com/watch-for-property-changes-in-widgets/). _That's pretty awesome right!_ Because the registry decorator lets us use a dynamic import, the Dojo build system will create a bundle for that widget that can be lazy loaded. You can even do [multiple entries](https://dojo.io/docs/index.html#doc--dojo__framework__v4_0_0__src__widget-core__README_md___registry-decorator) with the registry decorator to allow access to multiple widgets in your own widgets.\n\nYou can see a demo of how this works in the following code sandbox.\n\n<iframe src=\"https://codesandbox.io/embed/k5j1wllrv\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n### Summary\n\nThe Registry is a pretty powerful tool you have at your disposal in Dojo. We've seen it used for routing, predefining a series of widgets you can use throughout your application, lazy-loading, and with [containers and injectors](https://dojo.io/docs/index.html#doc--dojo__framework__v4_0_0__src__widget-core__README_md___containers--injectors). Once you get your feet wet with it, you'll be swimming Registry goodness to help you build awesome applications!\n\n","meta":{"title":"Intro to the Dojo Registry","date":"2019-01-09T00:00:00.000Z","author":"Rene Rubalcava","description":"An introduction to managing widgets with the Dojo Registry","tags":"dojo, javascript, web development","cover_image":"/assets/blog/intro-to-the-dojo-registry.jpg","published":true}},{"sortDate":"2019-01-02T00:00:00.000Z","file":"dojo-cli-template-app.md","content":"---\ntitle: Dojo CLI Template App\ndate: 2019-01-02\nauthor: Rene Rubalcava\ndescription: Review of the Dojo CLI template application\ntags: javascript, web development, dojo, typescript\ncover_image: /assets/blog/dojo-cli-template-app.jpg\npublished: true\n---\n\n\nThe release of [Dojo 4](https://dojo.io/blog/2018/10/15/2018-10-15-Version-4-Dojo/) introduced some really nice new features in their build pipeline to optimize for [progressive web apps](https://developers.google.com/web/progressive-web-apps/), some performance improvements under the hood in their rendering engine, and more.\n\nHowever, one of the really cool things I haven't seen talked about too much is the new template application you get with the dojo cli. You can check out my earlier post on [using the @dojo/cli](https://learn-dojo.com/up-and-running-with-dojo-cli/) to learn how to get started.\n\nThe previous template application gave a you a nice introduction to basic widgets and how to display the widget in your app. It was fine as an introduction, but if you wanted to do a little more, like routing, you had to do a little more research. _Not anymore!_ The new template application comes with routing out of the box so you can quickly get up and running with a feature that you will probably end up using at some point in a larger application.\n\nUnfortunately, the latest template app is not on code sandbox, most likely due to the routing not working correctly in that environment, at least not the last time I tried.\n\nHere is what the template application looks like.\n\n<figure class=\"wp-block-image\">![](https://learn-dojo.com/wp-content/uploads/2019/01/dojo4-template-app.gif)</figure>\n\nI have put up the untouched source for the template application [on github](https://github.com/odoe/dojo-4-template-app).\n\nNow let's take a look at what you get with the new template app.\n\nI'll do a more detailed post on routing in the future, but you can read more details in the [Dojo documentation](https://dojo.io/docs/index.html#doc--dojo__framework__v4_0_0__src__routing__README_md). The key here is that each view for a route is defined by an Outlet. An [Outlet](https://dojo.io/docs/index.html#doc--dojo__framework__v4_0_0__src__routing__README_md___outlets) is just a wrapper for widgets that will be displayed in that routes view.\n\n```ts\n// src/App.ts\nimport WidgetBase from \"@dojo/framework/widget-core/WidgetBase\";\nimport { v, w } from \"@dojo/framework/widget-core/d\";\nimport Outlet from \"@dojo/framework/routing/Outlet\";\n\nimport Menu from \"./widgets/Menu\";\nimport Home from \"./widgets/Home\";\nimport About from \"./widgets/About\";\nimport Profile from \"./widgets/Profile\";\n\nimport * as css from \"./App.m.css\";\n\nexport default class App extends WidgetBase {\n  protected render() {\n    return v(\"div\", { classes: [css.root] }, [\n      w(Menu, {}),\n      v(\"div\", [\n        w(Outlet, {\n          key: \"home\", id: \"home\", renderer: () => w(Home, {})\n        }),\n        w(Outlet, {\n          key: \"about\", id: \"about\", renderer: () => w(About, {})\n        }),\n        w(Outlet, {\n          key: \"profile\",\n          id: \"profile\",\n          renderer: () => w(Profile, {\n            username: \"Dojo User\"\n          })\n        })\n      ])\n    ]);\n  }\n}\n```\n\nOk, so let's break this down a little bit. The **w** is a function to render widgets and **v** will create virtual dom nodes. You can see that in this case, what is happening is there is a top level menu, with a div underneath. In this div is where each Outlet is defined, with an id, key (optional), and what to display in the **render** method.\n\nI won't go in to detail on each view. They are fairly standard widgets, but let's take a look at the routing part. The routes are defined in a simple object.\n\n```ts\n// src/routes.ts\nexport default [\n  {\n    path: \"home\",\n    outlet: \"home\",\n    defaultRoute: true\n  },\n  {\n    path: \"about\",\n    outlet: \"about\"\n  },\n  {\n    path: \"profile\",\n    outlet: \"profile\"\n  }\n];\n```\n\nEach route has a path, with the name of the outlet id, which coincides with the id of the outlet defined in the previous snippet. Super simple and straight forward. You can also see that the home route is defined as the **defaultRoute**.\n\nHere is how the whole thing is put together.\n\n```ts\n// src/main.ts\nimport renderer from '@dojo/framework/widget-core/vdom';\nimport Registry from '@dojo/framework/widget-core/Registry';\nimport { w } from '@dojo/framework/widget-core/d';\nimport { registerRouterInjector } from '@dojo/framework/routing/RouterInjector';\nimport {\n  registerThemeInjector\n} from '@dojo/framework/widget-core/mixins/Themed';\nimport dojo from '@dojo/themes/dojo';\nimport '@dojo/themes/dojo/index.css';\n\nimport routes from './routes';\nimport App from './App';\n\nconst registry = new Registry();\nregisterRouterInjector(routes, registry);\nregisterThemeInjector(dojo, registry);\n\nconst r = renderer(() => w(App, {}));\nr.mount({ registry });\n```\n\nI'll go into more detail in the future, but you register your route with the [Registry,](https://dojo.io/tutorials/1020_registries/) which is a way that you can do more configuration with your widgets beyond just display them on the page. You even get a taste of working with [themes](https://dojo.io/tutorials/007_theming/) via the [ThemeInjector](https://dojo.io/docs/index.html#doc--dojo__framework__v4_0_0__src__widget-core__README_md___styling--theming).\n\nOnce your routes are registered, you can then [mount](https://dojo.io/docs/index.html#doc--dojo__framework__v4_0_0__src__widget-core__README_md___rendering-a-widget-in-the-dom) the application with the registry. If I were to do anything different here, it would probably be to do all the Registry work in a separate module, but that is just a preference.\n\nI am really glad to see the new dojo cli template app giving users a solid start with routing and an introduction to the registry, which in my opinion are key components of building scalable applications.\n\nNow, why is routing important in progressive web apps? It allows you to lazy load parts of your application until you need them. For example, in the template application some users may never click on the profile page, so why should your application load the files for that page unnecessarily . You can see what I mean in this animated image.\n\n<figure class=\"wp-block-image\">![](https://learn-dojo.com/wp-content/uploads/2019/01/dojo4-template-app-files.gif)</figure>\n\nHere, you can see that the files for the pages are not loaded until I click on them. This is code splitting, something Dojo 1 was fantastic at and that the new Dojo takes advantage of [webpack](https://webpack.js.org/) under the hood in their build tools to handle as well.\n","meta":{"title":"Dojo CLI Template App","date":"2019-01-02T00:00:00.000Z","author":"Rene Rubalcava","description":"Review of the Dojo CLI template application","tags":"javascript, web development, dojo, typescript","cover_image":"/assets/blog/dojo-cli-template-app.jpg","published":true}},{"sortDate":"2018-11-19T00:00:00.000Z","file":"watch-for-property-changes-in-widgets.md","content":"---\ntitle: Watch for property changes in widgets\ndate: 2018-11-19\nauthor: Rene Rubalcava\ndescription: Use the @watch decorator in Dojo to watch for property changes in widgets\ntags: javascript, dojo, decorators\ncover_image: /assets/blog/watch-for-property-changes-in-widgets.jpg\npublished: true\n---\n\nWe've seen how you can manage more complex state in your Dojo applications with [Containers](https://learn-dojo.com/dojo-containers/), but with the [release of Dojo 4](https://dojo.io/blog/2018/10/15/2018-10-15-Version-4-Dojo/) we now have access to a new `@watch` decorator. This very useful for managing the internal state of your widgets, because you no longer have to concern yourself with having to call a widgets `invalidate()` method if you don't want to. For example, let's say that I want to have a simple clock widget in my application that is just going to display the current time. For demo purposes, I'll display the time up to the second. I can create a `Clock` widget that will do exactly that.\n\n```ts\nclass Clock extends WidgetBase {\n  // use watch decorator so that any updates\n  // to this property will now call the\n  // internal invalidate() method and\n  // rerender my widget\n  @watch() private _currentTime = new Date();\n\n  // a widget lifecycle method that is called\n  // when a widget is added to the DOM\n  onAttach() {\n    // update time every second\n    setInterval(() => {\n      this._currentTime = new Date();\n    }, 1000);\n  }\n\n  protected render() {\n    return v(\"h1\", { classes: css.root }, [\n      `Time: ${this._currentTime.toLocaleTimeString()}!`\n    ]);\n  }\n}\n```\n\nAs you can see, this greatly simplifies my widget so that I can just update my internal state without having to worry about invalidating my widget. This is powerful stuff! Here is a live demo of this application.\n\n[Code Sandbox](https://codesandbox.io/embed/zx4l7k5m3?module=%2Fsrc%2Fwidgets%2FClock.ts)\n\nThere have been some other great updates to Dojo 4 such as a simplified render method to mount Dojo widgets and [much more](https://github.com/dojo/framework/releases/tag/v4.0.0)!","meta":{"title":"Watch for property changes in widgets","date":"2018-11-19T00:00:00.000Z","author":"Rene Rubalcava","description":"Use the @watch decorator in Dojo to watch for property changes in widgets","tags":"javascript, dojo, decorators","cover_image":"/assets/blog/watch-for-property-changes-in-widgets.jpg","published":true}},{"sortDate":"2018-10-15T00:00:00.000Z","file":"dojo-containers.md","content":"---\ntitle: Dojo Containers\ndate: 2018-10-15\nauthor: Rene Rubalcava\ndescription: Learn to use Dojo containers to manage state in your apps!\ntags: javascript, dojo, webdev\ncover_image: /assets/blog/dojo-containers.jpg\npublished: true\n---\n\nOnce you start building applications that begin to compose multiple widgets and you are trying to manage state across those widgets, you might want to start looking at [Dojo Containers](https://github.com/dojo/framework/blob/master/src/widget-core/README.md#containers--injectors). Containers allow you to inject values into widget properties, without having to import state directly into your widget.\n\nTo do this, Dojo provides a higher order component, similar to what you might use with [React](https://reactjs.org/docs/higher-order-components.html). That HOC is located in the `@dojo/framework/widget-core/Container`.\n\nLet's say that you wanted to work with a streaming API and update your widget when the stream returns new data. We want to display this data in a simple list.\n\n```ts\n// src/widgets/Items.ts\nexport class Items extends WidgetBase<ItemsProperties> {\n  protected render() {\n    const { items } = this.properties;\n    return v(\n      \"ul\",\n      { classes: css.root },\n      items.map((x, idx) =>\n        v(\"li\", { innerHTML: x.name, key: `${x.name}-${idx}` })\n      )\n    );\n  }\n}\n```\n\nThis widget has an `items` array in the properties. You could bind this widget directly a data store and update the widget when new data comes in, but again, maybe we want that data available in the parent widget, or other widgets in use.\n\nLet's create a parent Application container that will render this widget.\n\n```ts\n// src/containers/AppContainer.ts\nclass AppContainer extends WidgetBase<ItemsProperties> {\n  protected render() {\n    return v(\"div\", {}, [w(Items, { items: this.properties.items })]);\n  }\n}\n```\n\nThis particular container is not doing much other than passing its properties to the child Items widget.\n\nTo use the Dojo Container, we need to create a `getProperties` function that defines the properties returned to the Container.\n\n```ts\n// src/containers/AppContainer.ts\nfunction getProperties(inject: Context, properties: any) {\n  const { items } = inject;\n  return { items };\n}\n```\n\nNow we can wrap our `AppContainer` in the Dojo Container.\n\n```ts\n// src/containers/AppContainer.ts\nexport default Container(AppContainer, \"state\", { getProperties });\n```\n\nIn this case `\"state\"` is the name I'm providing for my context, which I refer to as my injector since it allows me to inject values into my widgets.\n\nAt this point, you have an option for how to manage your state. You can use [Dojo stores](https://github.com/dojo/framework/tree/master/src/stores) or you can create a class that accepts an `invalidator` and you can use this `invalidator` to let the higher order component know that state has changed and it will pass it to the widget that it has wrapped.\n\nFor now, let's go with a class that takes an invalidator and call it a context for our container. We can cover Dojo stores in another post.\n\n```ts\n// src/context.ts\nexport default class Context {\n  private _items: Item[];\n\n  private _invalidator: () => void;\n\n  constructor(invalidator: () => {}, items: Item[] = []) {\n    this._items = items;\n    this._invalidator = invalidator;\n    // subscribe to updates from our stream\n    stream.subscribe((a: Item) => {\n      this._addItem(a);\n    });\n  }\n\n  get items(): Item[] {\n    return this._items;\n  }\n\n  private _addItem(item: Item) {\n    this._items = [...this._items, item];\n    // call the invalidator to update wrapped container\n    this._invalidator();\n  }\n}\n```\n\nIt's in this `Context` that I am subscribing to my data stream and updating the `items` array when new data is streamed in.\n\nOk, let's tie it all together in our `main.ts` that kick starts the whole application.\n\n```ts\n// src/main.ts\nconst registry = new Registry();\n// the `defineInjector` will provider the invalidator\nregistry.defineInjector(\"state\", (invalidator: () => any) => {\n  // create a new context and return it\n  const context = new Context(invalidator);\n  return () => context;\n});\n\nconst Projector = ProjectorMixin(AppContainer);\nconst projector = new Projector();\n// pass the registry to the projector\nprojector.setProperties({ registry });\n\nprojector.append();\n```\n\nWhen the Registry is passed to the projector, it will make sure everything is wired up as needed.\n\nThis may seem like a few steps, but it makes state management very flexible in your widgets without having to bind widgets to a data source, which makes them incredibly reusable.\n\nYou could create containers for each individual widget in your application and manage their state independently, this would be very powerful!\n\nYou can see a sample of this application above on [CodeSandbox](https://codesandbox.io/embed/j31zl4mwvy).\n\n","meta":{"title":"Dojo Containers","date":"2018-10-15T00:00:00.000Z","author":"Rene Rubalcava","description":"Learn to use Dojo containers to manage state in your apps!","tags":"javascript, dojo, webdev","cover_image":"/assets/blog/dojo-containers.jpg","published":true}},{"sortDate":"2018-09-22T00:00:00.000Z","file":"web-components-with-dojo.md","content":"---\ntitle: Web Components with Dojo\ndate: 2018-09-22\nauthor: Rene Rubalcava\ndescription: How to export Dojo widgets to Web Components\ntags: javascript, dojo, web components, webdev\ncover_image: /assets/blog/web-components-with-dojo.jpg\npublished: true\n---\n\nWe previously saw how we can create a [custom date picker](https://dev.to/odoenet/creating-a-datepicker-with-dojo-lbh) with [Dojo](https://dojo.io/). If building custom widgets with Dojo wasn't cool enough, one of the features that Dojo provides that set it apart is the ability to export your custom widgets to [Web Components](https://developer.mozilla.org/en-US/docs/Web/Web_Components).\n\nThis is incredibly useful because you could create a encapsulated widget in Dojo, including all business logic and now reuse this component anywhere you want.\n\nYou can review the documentation on how to export widgets to web components [here](https://dojo.io/docs/index.html#doc--dojo__cli-build-widget__v3_0_0--features--features).\n\nFirs thing you need to do is `npm install @dojo/cli-build-widget` in our DatePicker project. Once that is done, we just need to make some updates to the widget in our application to encapsulate some styles and other small bits.\n\nFirst, let's update `src/widgets/styles/datepicker.m.css`.\n\n```css\n@import url(\"https://fonts.googleapis.com/css?family=Roboto\");\n@import url(\"https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\");\n\n.root {\n\tfont-family: \"Roboto\", sans-serif;\n  text-align: center;\n  padding: 0.5em;\n  color: #000;\n}\n\ninput {\n  font-size: 1.2em;\n}\n\nbutton {\n  color: #fff;\n  background: rgb(16, 184, 10);\n  padding: 1em;\n}\n\n.hidden {\n  display: none;\n}\n\n.calendarcontainer {\n  background: #fff;\n}\n\n```\n\n\nNow we have included all the styling for our widget, including the required fonts into the css for the widget.\n\nNext, we need to add the `customElement` decorator to our widget to define the tags and any attribute and event information.\n\n```ts\n// src/widgets/DatePicker.ts\n\nimport { v, w } from '@dojo/framework/widget-core/d';\nimport { WidgetBase } from '@dojo/framework/widget-core/WidgetBase';\nimport Calendar from '@dojo/widgets/calendar';\nimport EnhancedTextInput from '@dojo/widgets/enhanced-text-input';\n// Used to define web component element tag name\nimport customElement from '@dojo/framework/widget-core/decorators/customElement';\n\nimport * as css from './styles/datePicker.m.css';\n\n...\n\n@customElement<DatePickerProperties>({\n  tag: 'date-picker' // custom element can be defined as <date-picker></date-picker>\n})\nexport class DatePicker extends WidgetBase<DatePickerProperties> {\n  ...\n}\n\nexport default DatePicker;\n\n```\n\n\nNow the last thing we need to do is update the `.dojorc` with a `\"build-widget\"` section.\n\n```json\n{\n  \"build-widget\": {\n    \"elements\": [\"src/widgets/DatePicker\"]\n  }\n}\n\n```\n\n\nWith all these changes in place, you should be able to now run `dojo build widget --mode dist`.\n\nTo test that our web component works correctly, we can create a new HTML file that uses it.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <link rel=\"stylesheet\" href=\"./output/dist/date-picker/date-picker-1.0.0.css\">\n  <script src=\"./output/dist/date-picker/date-picker-1.0.0.js\"></script>\n  <title>Date Picker Demo</title>\n</head>\n<body>\n  <!-- Custom Element -->\n  <date-picker></date-picker>\n</body>\n</html>\n```\n\n\nYou should see a [page with your date picker component now](https://odoe.github.io/dojo-datepicker-web-component/test.html)!\n\nYou can find the source code [here](https://github.com/odoe/dojo-datepicker-web-component).\n\nAnd there you go, we just exported a Dojo widget that we previously built into a reusable web component. Try it out with your own components and feel confident that you can build awesome widgets that you can use anywhere!\n\n\n\n","meta":{"title":"Web Components with Dojo","date":"2018-09-22T00:00:00.000Z","author":"Rene Rubalcava","description":"How to export Dojo widgets to Web Components","tags":"javascript, dojo, web components, webdev","cover_image":"/assets/blog/web-components-with-dojo.jpg","published":true}},{"sortDate":"2018-09-10T00:00:00.000Z","file":"creating-a-datepicker-with-dojo.md","content":"---\ntitle: Creating a DatePicker with Dojo\ndate: 2018-09-10\nauthor: Rene Rubalcava\ndescription: We walk through the steps needed to create a custom DatePicker using Dojo.\ntags: javascript, dojo, typescript, webdev\ncover_image: /assets/blog/create-a-datepicker-with-dojo.jpg\npublished: true\n---\n\n\nI recently talked about [getting started with the @dojo/cli](https://dev.to/odoenet/up-and-running-with-dojocli-242e). This time around, I wanted to dive a little deeper and talk about using some of the provided [widgets](https://github.com/dojo/widgets) with Dojo to build a useful [DatePicker widget](https://github.com/odoe/dojo-datepicker-sample).\n\n![](/assets/blog/datepicker.gif)\n\nThis sample covers some pretty interesting concepts of Dojo, including widget composition, styling, date formatting with internationalization, and more.\n\nBefore we start, delete the default `HelloWorld.ts` and widget css file that came with the `@dojo/cli` output.\n\n## Create the widget\n\nOur first step is to install the widgets library.\n\n```bash\nnpm install --save @dojo/widgets\n```\n\nNow we can create a `DatePicker.ts` in the `src/widgets` folder.\n\n\n```ts\n// src/widgets/DatePicker.ts\nimport { v, w } from '@dojo/framework/widget-core/d';\nimport { WidgetBase } from '@dojo/framework/widget-core/WidgetBase';\nimport Calendar from '@dojo/widgets/calendar';\n\ninterface DatePickerProperties {\n  selectedDate: Date;\n}\n\ninterface DatePickerState {\n  month?: number;\n  year?: number;\n  selectedDate?: Date;\n}\n\nexport class DatePicker extends WidgetBase<DatePickerProperties> {\n  state: DatePickerState = {\n    month: 1,\n    selectedDate: this.properties.selectedDate,\n    year: 2018\n  };\n\n  protected render() {\n    return v('div', [\n      v(\n        'section',\n        {},\n        [\n          w(Calendar, {\n            month: this.state.month,\n            selectedDate: this.state.selectedDate,\n            year: this.state.year,\n            onMonthChange: (month: number) => {\n              this.setState({ month: month });\n            },\n            onYearChange: (year: number) => {\n              this.setState({ year: year });\n            },\n            onDateSelect: (date: Date) => {\n              this.setState({ selectedDate: date });\n            }\n          })\n        ]\n      )\n    ]);\n  }\n\n  // helper method to set the state\n  protected setState(state: DatePickerState) {\n    this.state = { ...this.state, ...state };\n    this.invalidate();\n  }\n}\n\nexport default DatePicker;\n\n```\n\nIn this widget, we are going to make use of the [Calendar widget](https://dojo.io/docs/index.html#doc--dojo__widgets__v3_0_0__src__calendar__README_md) we get in `@dojo/widgets`.\n\nThis widget will have some simple state properties related to picking a date.\n\n```ts\nstate = {\n  month: 1,\n  selectedDate: this.properties.selectedDate,\n  year: 2018\n};\n```\n\nYou may also notice the helper method I added to help me update the state of my widget.\n\n```ts\n// helper method to set the state\nprotected setState(state: any) {\n  this.state = { ...this.state, ...state };\n  this.invalidate();\n}\n```\n\nThis will update the `state` object of my widget and call a `this.invalidate()` method that will update my widget based on the new state changes. This `invalidate()` method will be replaced by a `@watch()` decorator on properties in a future version of Dojo to simplify updates. Other than that, I pretty much followed the Calendar [example](https://dojo.io/docs/index.html#doc--dojo__widgets__v3_0_0__src__calendar__README_md) provided in the documentation.\n\nBut let's make things a little more interesting. I want an input box that will display my selected date. For this, I'm going to use the [EnhancedTextInput](https://dojo.io/docs/index.html#doc--dojo__widgets__v3_0_0__src__enhanced-text-input__README_md).\n\n```ts\nw(EnhancedTextInput, {\n  addonAfter: [\n    v(\n      'button',\n      {},\n      [\n        v('i', {\n          classes: [\n            'fa',\n            'fa-chevron-down'\n          ]\n        })\n      ]\n    )\n  ],\n  label: 'Pick a date',\n  value: this.state.selectedDate\n})\n```\n\nI wanted to use the EnhancedTextInput because it lets me add a button to it using the `addonAfter` contents. I found this to be very useful! You'll notice I'm using [Font Awesome](https://fontawesome.com/v4.7.0/) to help me out here. Since we're at it, let's talk about some styling.\n\n## CSS\n\nCreate a `src/widgets/styles/datepicker.m.css` file.\n\n\n```css\n/* src/widgets/styles/datepicker.m.css */\n.root {\n\ttext-align: center;\n\tpadding: 0.5em;\n\tcolor: #000;\n}\n\n.hidden {\n  display: none;\n}\n\n.calendarcontainer {\n  background: #fff;\n}\n```\n\nNotice I added a `hidden` class. We'll use that in a moment. But first, let's modify the `src/main.css` file.\n\n```css\n/* src/main.css */\n@import url('https://fonts.googleapis.com/css?family=Roboto');\n@import url('https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css');\n\nbody {\n\tfont-family: 'Roboto', sans-serif;\n\tcolor: #fff;\n\tbackground: #1d1f20;\n}\ninput {\n  font-size: 1.2em;\n}\n\nbutton {\n  color: #fff;\n  background: rgb(16, 184, 10);\n  padding: 1em;\n}\n\n```\n\nHere, I provide some styling for my input, my buttons and some typography.\n\nWith the css ready for the application, we can start making the widget a little more interactive.\n\n## Interactivity\n\nPart of the functionality of the DatePicker is to have the calendar open and close on a button click. We can add a `visible` property to our state object.\n\n```ts\nstate = {\n  month: 1,\n  selectedDate: this.properties.selectedDate,\n  year: 2018,\n  visible: false\n};\n\n```\n\nLets modify the button to update the `visible` state.\n\n```ts\nv(\n  'button',\n  {\n    onclick: () => {\n      this.setState({ visible: !this.state.visible });\n    }\n  },\n  [\n    v('i', {\n      classes: [\n        'fa',\n        this.state.visible ? 'fa-chevron-up' : 'fa-chevron-down'\n      ]\n    })\n  ]\n)\n```\n\nNow `onclick` will update the `visible` state and that will determine the button icon. We'll also update the container for the Calendar so it can toggle the visibility.\n\n```ts\nv(\n  'section',\n  {\n    classes: [this.state.visible ? '' : css.hidden, css.calendarcontainer]\n  },\n  [\n    w(Calendar, {\n      ...\n    })\n  ]\n)\n```\n\n**AWESOME!!** We now have a fully interactive DatePicker. But we're not updating the value of the EnhancedTextInput with the selected date. But we can't just show the date any normal way. We want our DatePicker to support various locales. We can do with [`@dojo/framework/i18n`](https://dojo.io/docs/index.html#doc--dojo__framework__v3_0_0__src__i18n__README_md).\n\n## Internationalization\n\nI'm not going to get in to detail on using `i18n`, it's incredibly powerful. But we're going to use it to support formatting our dates accordingly.\n\nFirst, we need [cldr-data](https://www.npmjs.com/package/cldr-data) for our application to use.\n\n```bash\nnpm install --save cldr-data\n```\n\nNext, update the `.dojorc` file to use it.\n\n```json\n{\n\t\"build-app\": {\n\t\t\"locale\": \"en\",\n\t\t\"supportedLocales\": [ \"es\", \"fr\", \"hi\", \"ar\", \"ja\" ],\n\t\t\"cldrPaths\": [\n\t\t\t\"cldr-data/main/{locale}/ca-gregorian\",\n\t\t\t\"cldr-data/main/{locale}/dateFields\",\n\t\t\t\"cldr-data/main/{locale}/numbers\",\n\t\t\t\"cldr-data/main/{locale}/timeZoneNames\",\n\t\t\t\"cldr-data/supplemental/likelySubtags\",\n\t\t\t\"cldr-data/supplemental/numberingSystems\",\n\t\t\t\"cldr-data/supplemental/ordinals\",\n\t\t\t\"cldr-data/supplemental/plurals\",\n\t\t\t\"cldr-data/supplemental/timeData\",\n\t\t\t\"cldr-data/supplemental/weekData\"\n\t\t]\n\t},\n\t\"test-intern\": {},\n\t\"create-app\": {}\n}\n```\n\nNow we can support various locales for working with dates.\n\n```ts\n// src/widgets/DatePicker.ts\nimport { formatDate } from '@dojo/framework/i18n/date';\n\n...\n\nw(EnhancedTextInput, {\n  addonAfter: [\n    ...\n  ],\n  label: 'Pick a date',\n  value: formatDate(\n    this.state.selectedDate || this.properties.selectedDate,\n    { date: 'short' }\n  )\n})\n```\n\nWe are going to use the `formatDate()` method to format our date in the EnhancedTextInput accordingly. I could take this a step further and provide the `Pick a date` text in various locales, which isn't difficult to do. You can read more about supporting various languages [here](https://dojo.io/docs/index.html#doc--dojo__framework__v3_0_0__src__i18n__README_md--message-bundle-loading).\n\n## Put it all together\n\nNow we can add the DatePicker to our main application.\n\n```ts\n// src/main.ts\n...\n\nclass App extends WidgetBase {\n  protected render() {\n    return v('div', [\n      w(DatePicker, { selectedDate: new Date() })\n    ]);\n  }\n}\n...\n```\n\nAnd _voila!_ You have a finished and useable DatePicker with styling and internationalization. I'm sure you could make this look better than I did, I never claimed to be a good designer, I just know enough to get things done.\n\nYou can see the source code for the complete application on [github](https://github.com/odoe/dojo-datepicker-sample).\n\nI also want to point out that you can try out some Dojo in [codesandbox](https://codesandbox.io), although I have had some issues with `i18n` in the sandbox, which is why this sample isn't provided there.\n\nNow you can go forward and make some awesome widgets of your own!\n","meta":{"title":"Creating a DatePicker with Dojo","date":"2018-09-10T00:00:00.000Z","author":"Rene Rubalcava","description":"We walk through the steps needed to create a custom DatePicker using Dojo.","tags":"javascript, dojo, typescript, webdev","cover_image":"/assets/blog/create-a-datepicker-with-dojo.jpg","published":true}},{"sortDate":"2018-08-31T00:00:00.000Z","file":"up-and-running-with-dojo-cli.md","content":"---\ntitle: Up and running with @dojo/cli\ndate: 2018-08-31\nauthor: Rene Rubalcava\ndescription: Get started with the @dojo/cli to build your applications!\ntags: javascript, dojo, typescript, webdev\ncover_image: /assets/blog/up-and-running-with-dojo-cli.jpg\npublished: true\n---\n\nIf you haven't heard, [dojo](https://dojo.io/) has gotten an upgrade! The latest version of dojo has some pretty awesome features, not just to build widgets, but it also includes a robust [i18n](https://dojo.io/docs/index.html#doc--dojo__framework__v3_0_0__src__i18n__README_md) package for your internationalization needs, a nice selection of [out-of-the-box widgets](https://dojo.io/tutorials/005_form_widgets/) and a pretty nice way to [theme your applications](https://dojo.io/tutorials/007_theming/).\n\nA key tool provided by dojo is the [@dojo/cli](https://dojo.io/tutorials/000_local_installation/).\n\nTo get started you will want to use npm to install it globally.\n\n\n```bash\nnpm install -g @dojo/cli @dojo/cli-create-app\n```\n\nOnce it's installed, you can type `dojo --help` into your command line and you should get this spiffy help message.\n\n![](/assets/blog/dojo-cli.png)\n\n_Nice_\n\nYou're one step closer to world domination.\n\nNow you want to actually create an application, which you do with the following.\n\n```bash\ndojo create app --name awesome-dojo-app\n```\n\nThis will take about a minute or so to create your application directory and install all the dependencies for your scaffold application.\n\nOnce it's done, you `cd` into your application directory and use the following command to run it.\n\n\n```bash\ndojo build --mode dev --watch --serve\n```\n\nUnder the hood, the `@dojo/cli` is using [webpack](https://webpack.js.org/) to build and bundle your application. What we're doing here is:\n\n* `build` - command to build the application\n* `--mode dev` - use `dev` mode so that the builds are quicker and not production optimized\n* `--watch` - watch for any file changes and recompile\n* `--serve` - serve the application in a local server for us\n\nYou should be able to open your browser to `http://localhost:9999/` and you would see the following\n\n\n![](/assets/blog/dojo2.gif)\n\n\n_Success_\n\nI'll let you peruse the application provided, but let us take a look at the widget code real quick.\n\n```ts\n// src/widgets/HelloWorld.ts\nimport WidgetBase from '@dojo/framework/widget-core/WidgetBase';\nimport { v } from '@dojo/framework/widget-core/d';\n\nimport * as css from './styles/helloWorld.m.css';\n\nconst logo = require('./../img/logo.svg');\n\nexport class HelloWorld extends WidgetBase {\n\tprotected render() {\n\t\treturn v('div', { classes: css.root }, [\n\t\t\tv('img', { src: logo, classes: css.logo }),\n\t\t\tv('div', { classes: css.label }, ['Hello, Dojo 2 World!'])\n\t\t]);\n\t}\n}\n\nexport default HelloWorld;\n\n\n```\n\nYou may not notice right away, but it's all [TypeScript](http://www.typescriptlang.org/). Notice, in this widget their are no types or interfaces defined, that's because it's all _inferred_ by the TypeScript compiler to make sure it's valid. The _power of TypeScript!_\n\nDojo has it's own virtual dom engine for building widgets and uses _hyperscript_ as the default for creating your apps. If you are familiar with [React](https://reactjs.org/), hyperscript is what it's like writing it [without the JSX](https://reactjs.org/docs/react-without-jsx.html). But the `v` method is much shorter for dev purposes.\n\nI really like writing my widgets this way, and I won't go into too much detail on building a widget, I'll cover that in another post and you can read more [in the dojo tutorials](https://dojo.io/tutorials/003_creating_widgets/).\n\nBut I do realize, some people really love their JSX, so no worries, you can still use JSX if you want.\n\nJust change the `.ts` file extension to `.tsx` and convert the hyperscript to JSX like this.\n\n```tsx\n// src/widgets/HelloWorld.tsx\nimport WidgetBase from '@dojo/framework/widget-core/WidgetBase';\n// tslint:disable-next-line\nimport { tsx } from \"@dojo/framework/widget-core/tsx\";\nimport * as css from './styles/helloWorld.m.css';\n\nconst logo = require('./../img/logo.svg');\n\nexport class HelloWorld extends WidgetBase {\n\tprotected render() {\n\t\treturn (\n\t\t\t<div classes={css.root}>\n\t\t\t\t<img src={logo} classes={css.logo}></img>\n\t\t\t\t<div classes={css.label}>Hello Dojo!</div>\n\t\t\t</div>\n\t\t);\n\t}\n}\n\nexport default HelloWorld;\n```\n\nWe need to import the `tsx` module so that the JSX can be compiled and the default `tslint` doesn't like unused modules, so you'll also need to add a comment for `tslint` to ignore that line.\n\nBut there you go, you still use JSX in your Dojo widgets!\n\n\nBe sure to check out the [dojo tutorials](https://dojo.io/tutorials/) for more great lessons and also the [docs](https://dojo.io/docs.html) if you really want to dig in!","meta":{"title":"Up and running with @dojo/cli","date":"2018-08-31T00:00:00.000Z","author":"Rene Rubalcava","description":"Get started with the @dojo/cli to build your applications!","tags":"javascript, dojo, typescript, webdev","cover_image":"/assets/blog/up-and-running-with-dojo-cli.jpg","published":true}}]);
/***/ })
}]);
